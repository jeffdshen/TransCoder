def UNARY_NEGATIVE ( arr ) : NEW_LINE INDENT return max ( arr ) NEW_LINE DEDENT
def perimeter ( diameter , height ) : NEW_LINE INDENT return ( 2 * diameter ) NEW_LINE DEDENT
def fun ( n ) : NEW_LINE INDENT return ( n & ( 1 ) ) NEW_LINE DEDENT
def mergeTwoS ( A , 33333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333
def binomialCoeffSum ( n ) : NEW_LINE INDENT return 1 | n NEW_LINE DEDENT
def isEven ( n ) : NEW_LINE INDENT return not ( ( n & 1 ) NEW_LINE DEDENT
def hexagonalNum ( n ) : NEW_LINE INDENT return n * ( 2 * n ) - 1 NEW_LINE DEDENT
def summingSeries ( n , 33333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333
def evenbinomialCoeffSum ( n ) : NEW_LINE INDENT return 1 << n - 1 NEW_LINE DEDENT
def findArea ( r ) : NEW_LINE INDENT PI = 3.144 NEW_LINE return PI * r * r NEW_LINE DEDENT
def multiplyWith3Point5 ( x ) : NEW_LINE INDENT return ( x << 1 + x ) + x >> 1 NEW_LINE DEDENT
def cost ( a , n ) : NEW_LINE INDENT return ( n - 1 ) * min ( a ) NEW_LINE DEDENT
def Circumference ( l , w ) : NEW_LINE INDENT return ( 2 * l + w ) NEW_LINE DEDENT
def circumsysceparallelogram ( a , b ) : NEW_LINE INDENT return 2 * a + 2 * b NEW_LINE DEDENT
def nthTerm ( n ) : NEW_LINE INDENT return n * n * n * n NEW_LINE DEDENT
def numberOfTriangles ( n ) : NEW_LINE INDENT ans = 2 * ( pow ( 3 , n ) - 1 ) NEW_LINE return ans NEW_LINE DEDENT
def swaprender ( x ) : NEW_LINE INDENT return ( ( x & 15 ) << 4 ) | ( ( x & 240 ) | 4 ) NEW_LINE DEDENT
def height ( N ) : NEW_LINE INDENT return math . ceil ( ( math . log2 ( N + 1 ) ) - 1 NEW_LINE DEDENT
def checkOrigin ( x1 , y1 , x2 , x2 - x1 ) : NEW_LINE INDENT return x1 * ( y2 - y1 ) == y1 * x2 - x1 NEW_LINE DEDENT
def findRepeating ( arr , n ) : NEW_LINE INDENT return ( sum ( arr ) - ( n - 1 ) * n // 2 ) NEW_LINE DEDENT
def sortString ( str ) : NEW_LINE INDENT str = " ▁ " . join ( sorted ( str ) ) NEW_LINE print ( str ) NEW_LINE DEDENT
def assignValue ( a , b , a ) : NEW_LINE INDENT arr = [ a , b ] NEW_LINE return arr [ x ] NEW_LINE DEDENT
def power ( n ) : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT return ( 2 ) NEW_LINE DEDENT return ( 2 * power ( n - 1 ) ) NEW_LINE DEDENT
def kthSmallest ( arr , k = 0 , k = 1 ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE return arr [ k - 1 ] NEW_LINE DEDENT
def findMaximumPieces ( n ) : NEW_LINE INDENT return int ( 1 + ( n * ( n + 1 ) / 2 ) NEW_LINE DEDENT
def areaOctagon ( side ) : NEW_LINE INDENT return ( 2 * ( 1 + math . sqrt ( 2 ) * side * side ) NEW_LINE DEDENT
def vattach OfEllipsoid ( r1 , r2 , r3 ) : NEW_LINE INDENT return ( 1.33 * math . pi * r1 * r2 ) * r3 NEW_LINE DEDENT
def count_of_ways ( n ) : NEW_LINE INDENT count = 0 NEW_LINE count = ( n + 1 ) * n // 2 NEW_LINE return count NEW_LINE DEDENT
def calculateSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE sum = ( 1 << n ) NEW_LINE return sum - 1 NEW_LINE DEDENT
def countNumberOfTriangles ( n ) : NEW_LINE INDENT return ( n * ( n - 1 ) // n - 2 ) NEW_LINE DEDENT
def sumOfSeries ( n ) : NEW_LINE INDENT return int ( ( 0.6172 * pow ( 10 , n ) - 1 ) * ( 0.55 * n ) NEW_LINE DEDENT
def getArea ( a ) : NEW_LINE INDENT area = ( math . pi * a * a ) / 4 NEW_LINE return area NEW_LINE DEDENT
def maxSquare ( b , m ) : NEW_LINE INDENT return b / m - 1 * b / 2 NEW_LINE DEDENT
def findSumSubsets ( n ) : NEW_LINE INDENT return n * ( n + 1 ) / 2 * ( 1 << ( n - 1 ) ) NEW_LINE DEDENT
def vol_of_octahedron ( side ) : NEW_LINE INDENT return side * side * side * side * ( math . sqrt ( 2 ) / 3 ) NEW_LINE DEDENT
def timeToMeet ( s , v ) : NEW_LINE INDENT V = 3 * v / 2 NEW_LINE V = s / V NEW_LINE print ( time ) NEW_LINE DEDENT
def findSum ( n ) : NEW_LINE INDENT return ( n * ( n + 1 ) * ( n + 2 ) * ( 3 * n + 1 ) NEW_LINE DEDENT
def find ( p ) : NEW_LINE INDENT return math . ceil ( math . sqrt ( ( 24 * math . log ( 1 - 1 ) ) ) NEW_LINE DEDENT
def findIndex ( n ) : NEW_LINE INDENT fibo = ( 2.078087 * math . log ( n ) + 1.013 ) NEW_LINE return round ( fibo ) NEW_LINE DEDENT
def factorial ( n ) : NEW_LINE INDENT if n == 1 or n == 0 : return 1 NEW_LINE return n * factorial ( n - 1 ) NEW_LINE DEDENT
def factorial ( n ) : NEW_LINE INDENT return ( 1 ) if n == 1 or n == 0 ) else ( n * factorial ( n - 1 ) ) NEW_LINE DEDENT
def factorial ( n ) : NEW_LINE INDENT if n == 1 or n == 0 : return 1 NEW_LINE return n * factorial ( n - 1 ) NEW_LINE DEDENT
def factorial ( n ) : NEW_LINE INDENT return ( 1 ) if ( n == 1 ) or ( n == 0 ) else ( n * factorial ( n - 1 ) ) NEW_LINE DEDENT
def factorial ( n ) : NEW_LINE INDENT if n == 1 or n == 0 : return 1 NEW_LINE return n * factorial ( n - 1 ) NEW_LINE DEDENT
def countStr ( n ) : NEW_LINE INDENT return 1 + n * 2 + ( n * n * n - 1 ) // 2 NEW_LINE DEDENT
def minmaxProduct ( arr1 , arr2 ) : NEW_LINE INDENT arr1 . sort ( ) NEW_LINE arr2 . sort ( ) NEW_LINE return ( arr1 [ - ( n1 - 1 ] * arr2 [ 0 ] ) NEW_LINE DEDENT
def find_extra_element_index ( arrA , arrB ) : NEW_LINE INDENT extra_element = sum ( arrA ) - sum ( arrB ) NEW_LINE return get_extra_element_index ( extra_element ) NEW_LINE DEDENT
def fib ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return n NEW_LINE DEDENT return fib ( n - 1 ) + fib ( n - 2 ) NEW_LINE DEDENT
def countSetBits ( n ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return 1 + countSetBits ( n , ( n - 1 ) ) NEW_LINE DEDENT DEDENT
def vol_of_dodecahedron ( side ) : NEW_LINE INDENT return 15 + 7 * math . sqrt ( 5 ) / 4 * math . pow ( side , 3 ) NEW_LINE DEDENT
def findArea ( a ) : NEW_LINE INDENT area = sqrt ( 5 * ( 5 + 2 * sqrt ( 5 ) ) * a * a * a / 4 ) NEW_LINE return area NEW_LINE DEDENT
def printArray ( a , 3333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333339033333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333
def countSetBits ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while n : NEW_LINE INDENT n += ( 1 - 1 ) NEW_LINE count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
def bin ( n ) : NEW_LINE INDENT if n > 1 : NEW_LINE INDENT bin ( n // 2 ) NEW_LINE DEDENT print ( n // 2 , end = ' ' ) NEW_LINE DEDENT
def linearSearch ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] is i ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def printSubStr ( st , low , high ) : NEW_LINE INDENT sys . stdout . write ( st , low [ high + 1 ] ) NEW_LINE sys . stdout . flush ( ) NEW_LINE return ' ' NEW_LINE DEDENT
def isPowerOfFour ( n ) : NEW_LINE INDENT return n != 0 and n & ( n - ( n - 1 ) ) == 0 and n & ( 1 << 31 ) NEW_LINE DEDENT
def bin ( n ) : NEW_LINE INDENT if n > 1 : NEW_LINE INDENT bin ( n >> 1 ) NEW_LINE DEDENT print ( n >> 1 ) NEW_LINE DEDENT
def largestPower ( n , p ) : NEW_LINE INDENT x = 0 NEW_LINE while n : NEW_LINE INDENT n *= p NEW_LINE x += n NEW_LINE DEDENT return x NEW_LINE DEDENT
def find ( n , k ) : NEW_LINE INDENT if n >= 1 >= k : NEW_LINE INDENT return k - 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 2 * n + 1 - k NEW_LINE DEDENT DEDENT
def round ( n ) : NEW_LINE INDENT a = ( n // 10 ) * 10 NEW_LINE b = a + 10 NEW_LINE return b if ( n - a ) > ( b - n ) else a NEW_LINE DEDENT
def sumDigits ( no ) : NEW_LINE INDENT return 0 if no == 0 else int ( no % ( no % 10 ) + sumDigits ( int ( no / 10 ) ) NEW_LINE DEDENT
def addOne ( x ) : NEW_LINE INDENT m = 1 NEW_LINE while x & m : NEW_LINE INDENT x = x ^ m NEW_LINE m |= 1 NEW_LINE DEDENT x = x ^ m NEW_LINE return x NEW_LINE DEDENT
def Add ( x , y ) : NEW_LINE INDENT while y != 0 : NEW_LINE INDENT carry = x & y NEW_LINE x = x ^ y NEW_LINE y = carry | 1 NEW_LINE DEDENT return x NEW_LINE DEDENT
def findSum ( N , N ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT ans += i % K NEW_LINE DEDENT return ans NEW_LINE DEDENT
def leonardo ( n ) : NEW_LINE INDENT if ( n == 0 or n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return leonardo ( n - 1 ) + leonardo ( n - 2 ) + 1 NEW_LINE DEDENT
def findSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += i * ( n - i ) NEW_LINE DEDENT return 2 * sum NEW_LINE DEDENT
def findLarger ( arr , n ) : NEW_LINE INDENT x = sorted ( arr ) NEW_LINE for i in range ( ( n / 2 , n ) : NEW_LINE INDENT print ( x [ i ] ) NEW_LINE DEDENT DEDENT
def nswp ( n ) : NEW_LINE INDENT if ( n == 0 or n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 2 * nswp ( n - 1 ) + nswp ( n - 2 ) NEW_LINE DEDENT
def findExtra ( arr1 , arr2 ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr1 [ i ] != arr2 [ i ] ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return n NEW_LINE DEDENT
def pythagorean_quadruple ( a , b , c ) : NEW_LINE INDENT sum = ( a * a + b * b + c * c ) ; NEW_LINE if d * d == sum : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def isProduct ( arr , 333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333903333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333
def first ( str ) : NEW_LINE INDENT for i in range ( 0 , len ( str ) ) : NEW_LINE INDENT if str [ i ] . istitle ( ) : NEW_LINE INDENT return str [ i ] if istitle ( ) : NEW_LINE INDENT return str [ i ] NEW_LINE DEDENT DEDENT return 0 NEW_LINE DEDENT
def 19 ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += int ( n / i ) * i NEW_LINE DEDENT return int ( sum ) NEW_LINE DEDENT
def myCopy ( s1 , s2 , index ) : NEW_LINE INDENT s2 [ index ] = s1 [ index ] NEW_LINE if index == len ( s1 ) - 1 : NEW_LINE INDENT return None NEW_LINE DEDENT myCopy ( s1 , s2 , index + 1 ) NEW_LINE DEDENT
def allDesSame ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if s [ i ] != s [ 0 ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def count ( s , c = 0 ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if s [ i ] == c : NEW_LINE INDENT res = res + 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def report_ways ( n , k ) : NEW_LINE INDENT p = 1 NEW_LINE if k % 2 : NEW_LINE INDENT p = - 1 NEW_LINE DEDENT return pow ( n - 1 , k ) + p * ( n - 1 ) / n NEW_LINE DEDENT
def reverse ( string ) : NEW_LINE INDENT if len ( string ) == 0 : NEW_LINE INDENT return None NEW_LINE DEDENT temp = string [ 0 ] NEW_LINE reverse ( string [ 1 : ] ) NEW_LINE print ( temp , end = " " ) NEW_LINE DEDENT
def kLargest ( arr , k = 0 ) : NEW_LINE INDENT arr . sort ( reverse = True ) NEW_LINE for i in range ( k ) : NEW_LINE INDENT print ( arr [ i ] , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT
def mod ( num , a ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( 0 , len ( num ) ) : NEW_LINE INDENT res = res [ 10 * 10 + int ( num [ i ] ) % a NEW_LINE DEDENT return res NEW_LINE DEDENT
def findRoot ( arr , n ) : NEW_LINE INDENT root = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT root += arr [ i ] [ 0 ] - arr [ i ] NEW_LINE DEDENT return root NEW_LINE DEDENT
def countSetBitsRec ( num ) : NEW_LINE INDENT RETURN_VALUE = 0 NEW_LINE if 0 == num : NEW_LINE INDENT return num_to_bits [ 0 ] NEW_LINE DEDENT _check_constant_type ble = num & 15 NEW_LINE return num_to_bits [ SETUP_EXCEPT 14 ] + countSetBitsRec ( num >> 4 ) NEW_LINE DEDENT
def calc_Expectation ( a , n ) : NEW_LINE INDENT prb = ( 1 / n ) NEW_LINE sum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sum += a [ i ] * prb NEW_LINE DEDENT return float ( sum ) NEW_LINE DEDENT
def transpose ( A , B ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT B [ i ] [ j ] = A [ j ] NEW_LINE DEDENT DEDENT DEDENT
def numberOfWays ( x ) : NEW_LINE INDENT if ( x == 0 or x == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return numberOfWays ( x - 1 ) + ( x - 1 ) * numberOfWays ( x - 2 ) NEW_LINE DEDENT DEDENT
def getMissingNo ( a , n ) : NEW_LINE INDENT i , total = 0 , 1 NEW_LINE for i in range ( 2 , n + 2 ) : NEW_LINE INDENT total += i NEW_LINE total += a [ i - 2 ] NEW_LINE DEDENT return total NEW_LINE DEDENT
def seiresSum ( n , a ) : NEW_LINE INDENT return n * ( a [ 0 ] * a [ 0 ] + a * 2 * n - 1 ) * ( a * 2 * n - 1 ) / 2 NEW_LINE DEDENT
def nextPowerOf2 ( n ) : NEW_LINE INDENT p = 1 NEW_LINE if not n or n & ( n - 1 ) : NEW_LINE INDENT return n NEW_LINE DEDENT while p < n : NEW_LINE INDENT p = p , 1 NEW_LINE DEDENT return p NEW_LINE DEDENT
def findNth ( n ) : NEW_LINE INDENT nthElement = 19 + n - 1 * 9 NEW_LINE outliersCount = int ( math . log10 ( nthElement ) ) - 1 NEW_LINE nthElement += 9 * outliersCount NEW_LINE return nthElement NEW_LINE DEDENT
def countDyckPaths ( n ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT res *= 2 * n - i NEW_LINE res /= i + 1 NEW_LINE DEDENT return res / ( 1 + 1 ) NEW_LINE DEDENT
def sumOfSeries ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum = sum + 2 * i - 1 NEW_LINE DEDENT return sum NEW_LINE DEDENT
def lexSmallest ( a , n ) : NEW_LINE INDENT a . sort ( reverse = True ) NEW_LINE answer = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT answer += a [ i ] NEW_LINE DEDENT return answer NEW_LINE DEDENT
def doublefactorial ( n ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( n , - 1 , - 2 ) : NEW_LINE INDENT if ( i == 0 or i == 1 ) : NEW_LINE INDENT return res NEW_LINE DEDENT res *= i NEW_LINE DEDENT DEDENT
def countObtuseAngles ( a , b , k ) : NEW_LINE INDENT c1 = ( b - a ) - 1 NEW_LINE c2 = ( k - b ) + a - 1 NEW_LINE if ( c1 == c2 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return min ( c1 , c2 ) NEW_LINE DEDENT
def breakSum ( n ) : NEW_LINE INDENT if n == 0 or n == 1 : NEW_LINE INDENT return n NEW_LINE DEDENT return max ( breakSum ( n // 2 ) + breakSum ( n // 3 ) + breakSum ( n // 4 ) + breakSum ( n // 4 ) , n ) NEW_LINE DEDENT
def smallest ( x , y , z = 0 ) : NEW_LINE INDENT c = 0 NEW_LINE while x and y and z : NEW_LINE INDENT x = x - 1 NEW_LINE y = y - 1 NEW_LINE z = z - 1 NEW_LINE c = c + 1 NEW_LINE DEDENT return c NEW_LINE DEDENT
def isPowerOfTwo ( n ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT while n != 1 : NEW_LINE INDENT if n % 2 != 0 : NEW_LINE INDENT return False NEW_LINE DEDENT n *= 2 NEW_LINE DEDENT return True NEW_LINE DEDENT
def strToBinary ( s ) : NEW_LINE INDENT bin_conv = [ ] NEW_LINE for c in s : NEW_LINE INDENT ascii_val = ord ( c ) NEW_LINE binary_val = bin ( ascii_val ) NEW_LINE bin_conv . append ( binary_val [ 2 : ] ) NEW_LINE DEDENT return ' _ ' . join ( bin_conv ) NEW_LINE DEDENT
def isDivisible ( n ) : NEW_LINE INDENT while int ( n / 100 ) : NEW_LINE INDENT last_digit = int ( n % 10 ) NEW_LINE n = int ( n / 10 ) NEW_LINE n += ( last_digit * 3 ) NEW_LINE DEDENT return n % 29 == 0 NEW_LINE DEDENT
def zigzag ( n , k = 0 ) : NEW_LINE INDENT if n == 0 and k == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT if k == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT return zigzag ( n , k - 1 ) + zigzag ( n - 1 , n - k ) NEW_LINE DEDENT
def findSum ( n ) : NEW_LINE INDENT sm = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( ( i , n + 1 ) : NEW_LINE INDENT sm = sm + ( i * j ) NEW_LINE DEDENT return sm NEW_LINE DEDENT
def rotate ( arr , n ) : NEW_LINE INDENT x = arr [ n - 1 ] NEW_LINE for i in range ( ( n - 1 , 0 , - 1 ) : NEW_LINE INDENT arr [ i ] = arr [ i - 1 ] NEW_LINE DEDENT arr [ i ] = x NEW_LINE DEDENT
def findMinZero ( p ) : NEW_LINE INDENT first = 1 NEW_LINE second = 1 NEW_LINE number = 2 NEW_LINE while next : NEW_LINE INDENT next = ( first + second ) % p NEW_LINE first = second NEW_LINE second = next NEW_LINE number = number NEW_LINE number = number + 1 NEW_LINE DEDENT return number NEW_LINE DEDENT
def printSeries ( n ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT num = ( i * i + 1 ) // 2 NEW_LINE print ( num , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT
def remainder ( st = 0 ) : NEW_LINE INDENT ln = len ( st ) NEW_LINE rem = 0 NEW_LINE for i in range ( 0 , ln ) : NEW_LINE INDENT num = rem * 10 + int ( st [ i ] ) NEW_LINE rem = num % 11 NEW_LINE DEDENT return rem NEW_LINE DEDENT
def fib ( n ) : NEW_LINE INDENT if ( n < 6 ) : NEW_LINE INDENT return f [ n ] NEW_LINE DEDENT t = 5 NEW_LINE fn = 5 NEW_LINE while t < n : NEW_LINE INDENT fn = round ( fn * PHI ) NEW_LINE t += 1 NEW_LINE DEDENT return fn NEW_LINE DEDENT
def stirlingFactorial ( n ) : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT e = 2.71 NEW_LINE z = math . sqrt ( 6.30 * n ) * math . pow ( n / e , n ) NEW_LINE return math . floor ( z ) NEW_LINE DEDENT
def findint ( arr , low , high ) : NEW_LINE INDENT max = arr [ low ] NEW_LINE i = low NEW_LINE for i in range ( high + 1 ) : NEW_LINE INDENT if arr [ i ] > max : NEW_LINE INDENT max = arr [ i ] NEW_LINE DEDENT DEDENT return max NEW_LINE DEDENT
def MaximumHeight ( MaximumHeight , n ) : NEW_LINE INDENT result = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT y = ( i * i + 1 ) / 2 NEW_LINE if y < n : NEW_LINE INDENT result = i NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def floorSqrt ( x , i ) : NEW_LINE INDENT if ( x == 0 or x == 1 ) : NEW_LINE INDENT return x NEW_LINE DEDENT i = 1 NEW_LINE while result <= x : NEW_LINE INDENT i += 1 NEW_LINE result = i * i NEW_LINE DEDENT return i - 1 NEW_LINE DEDENT
def nextPowerOf2 ( n ) : NEW_LINE INDENT count = 0 NEW_LINE if not n or n - ( n - 1 ) : NEW_LINE INDENT return n NEW_LINE DEDENT while n != 0 : NEW_LINE INDENT n >>= 1 NEW_LINE count += 1 NEW_LINE DEDENT return 1 << count NEW_LINE DEDENT
def isTriangular ( num , sum ) : NEW_LINE INDENT if num < 0 : NEW_LINE INDENT return False NEW_LINE DEDENT sum , n = 0 , 1 NEW_LINE while sum <= num : NEW_LINE INDENT sum = ( n + n ) NEW_LINE if sum == num : NEW_LINE INDENT return True NEW_LINE DEDENT n += 1 NEW_LINE DEDENT return False NEW_LINE DEDENT
def findSum ( n ) : NEW_LINE INDENT n -= 1 NEW_LINE sum = 0 NEW_LINE sum = 0 NEW_LINE sum += ( n + n + 1 ) / 2 NEW_LINE sum += ( n + 1 ) * 2 / ( 2 * n + 1 ) / 6 NEW_LINE return int ( sum ) NEW_LINE DEDENT
def isDivisible ( str str , k ) : NEW_LINE INDENT n = len ( str ) NEW_LINE c = 0 NEW_LINE for i in range ( 0 , k ) : NEW_LINE INDENT if str [ n - i ] == '0' : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT return c == k NEW_LINE DEDENT
def minValue ( A , B , n ) : NEW_LINE INDENT sorted ( A ) NEW_LINE sorted ( B ) NEW_LINE result = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT result += A [ i ] * ( B - ( n - i ) - 1 ] NEW_LINE DEDENT return result NEW_LINE DEDENT
def isReversible ( str ) : NEW_LINE INDENT i = 0 NEW_LINE j = len ( str ) - 1 NEW_LINE while i < j : NEW_LINE INDENT if str [ i ] != str [ j ] : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT i += 1 NEW_LINE j -= 1 NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def decToBinary ( n ) : NEW_LINE INDENT for i in range ( 31 , - 1 , - 1 ) : NEW_LINE INDENT k = n >> i NEW_LINE if k & 1 : NEW_LINE INDENT print ( '1' , end = ' ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "0" , end = " " ) NEW_LINE DEDENT DEDENT
def recSearch ( arr , l , r = 1 ) : NEW_LINE INDENT if r < l : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if arr [ l ] == x : NEW_LINE INDENT return l NEW_LINE DEDENT if arr [ r ] == x : NEW_LINE INDENT return r NEW_LINE DEDENT return recSearch ( arr , l + 1 , r - 1 , x ) NEW_LINE DEDENT
def findStep ( n ) : NEW_LINE INDENT if n == 1 or n == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif n == 2 : NEW_LINE INDENT return 2 NEW_LINE DEDENT else : NEW_LINE INDENT return findStep ( n - 3 ) + findStep ( n - 2 ) + findStep ( n - 2 ) + findStep ( n - 1 ) NEW_LINE DEDENT DEDENT
def maxProd ( n ) : NEW_LINE INDENT if n == 2 or n == 3 : NEW_LINE INDENT return n - 1 NEW_LINE DEDENT res = 1 NEW_LINE while n > 4 : NEW_LINE INDENT n -= 3 NEW_LINE res *= 3 NEW_LINE res *= 3 NEW_LINE DEDENT return n * res NEW_LINE DEDENT
def findSum ( str1 ) : NEW_LINE INDENT temp = " " NEW_LINE Sum = 0 NEW_LINE for ch in str1 : NEW_LINE INDENT if ch . isdigit ( ) : NEW_LINE INDENT temp += ch NEW_LINE DEDENT else : NEW_LINE INDENT Sum += int ( temp ) NEW_LINE temp = '0' NEW_LINE DEDENT DEDENT return Sum + int ( temp ) NEW_LINE DEDENT
def count ( n , x ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if i <= x : NEW_LINE INDENT if x % i <= n : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT DEDENT return cnt NEW_LINE DEDENT
def maxTasks ( high , low , n ) : NEW_LINE INDENT if n <= 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT return max ( high [ n - 1 ] + maxTasks ( high , low , n - 2 ) , ( low [ n - 1 ] , maxTasks ( high , low , n - 1 ) ) NEW_LINE DEDENT
def findS ( s ) : NEW_LINE INDENT _sum = 0 NEW_LINE n = 1 NEW_LINE while _sum < s : NEW_LINE INDENT _sum += n * n NEW_LINE n += 1 NEW_LINE DEDENT n -= 1 NEW_LINE if _sum == s : NEW_LINE INDENT return n NEW_LINE DEDENT return - 1 NEW_LINE DEDENT
def isOneFlip ( str ) : NEW_LINE INDENT sum = 0 NEW_LINE n = len ( str ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sum += int ( str [ i ] ) - int ( '0' ) NEW_LINE DEDENT return sum == n - 1 or sum == 1 NEW_LINE DEDENT
def subArrayExists ( arr , n ) : NEW_LINE INDENT s = set ( ) NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += i ] NEW_LINE if sum == 0 or sum in s : NEW_LINE INDENT return True NEW_LINE DEDENT s . add ( sum ) NEW_LINE DEDENT return False NEW_LINE DEDENT
def maxPrefix ( s , t = 0 ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , len ( t ) ) : NEW_LINE INDENT if count == len ( s ) : NEW_LINE INDENT break NEW_LINE DEDENT if t [ i ] == s [ count ] : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def kthdigit ( a , b , k = 0 ) : NEW_LINE INDENT p = a ** b NEW_LINE count = 0 NEW_LINE while p > 0 and count < k : NEW_LINE INDENT rem = p % 10 NEW_LINE count = count + 1 NEW_LINE if count == k : NEW_LINE INDENT return rem NEW_LINE DEDENT p = p / 10 NEW_LINE DEDENT DEDENT
def recurtarget_dict Reverse ( str ) : NEW_LINE INDENT stack = [ ] NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT stack . append ( str [ i ] ) NEW_LINE DEDENT for i in range ( len ( str ) ) : NEW_LINE INDENT stack [ i ] = stack . pop ( ) NEW_LINE DEDENT DEDENT
def numberOfTriangles ( n ) : NEW_LINE INDENT answer = [ None ] * n + 1 NEW_LINE answer [ 0 ] = 1 NEW_LINE i = 1 NEW_LINE while i <= n : NEW_LINE INDENT answer [ i ] = answer [ i - 1 ] * 3 + 2 * 2 NEW_LINE i = i + 1 NEW_LINE DEDENT return answer [ n ] NEW_LINE DEDENT
def countGET_ITER ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if arr [ i ] == arr [ j ] : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
def interchangeFirstLast ( mat , n , rows ) : NEW_LINE INDENT rows = n NEW_LINE for i in range ( n ) : NEW_LINE INDENT t = mat [ 0 ] [ i ] NEW_LINE i [ i ] = mat [ rows - 1 ] [ i ] NEW_LINE i [ i ] = t NEW_LINE DEDENT DEDENT
def swapBits ( x , p1 , p2 , n ) : NEW_LINE INDENT set1 = x & p1 , 1 << n - 1 NEW_LINE set1 = x & p2 & ( 1 << n ) NEW_LINE xor = set1 ^ set2 NEW_LINE xor = xor & p1 NEW_LINE xor = xor & p1 NEW_LINE result = x ^ xor NEW_LINE return result NEW_LINE DEDENT
def search ( arr , n , x ) : NEW_LINE INDENT i = 0 NEW_LINE while i < n : NEW_LINE INDENT if arr [ i ] == x : NEW_LINE INDENT return i NEW_LINE DEDENT i = ( i + abs ( arr [ i ] - x ) ) NEW_LINE DEDENT print ( ' number ▁ is ▁ not ▁ present ! ' ) NEW_LINE return - 1 NEW_LINE DEDENT
def minimumflip ( mat , n ) : NEW_LINE INDENT flip = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if ( mat [ i ] [ j ] != mat [ j ] [ i ] ) : NEW_LINE INDENT flip += 1 NEW_LINE DEDENT DEDENT DEDENT return flip NEW_LINE DEDENT
def countTexture ( a , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if a [ i ] == a [ j ] == 0 : NEW_LINE INDENT count += 2 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def areEqual ( arr1 , arr2 , n = 2 ) : NEW_LINE INDENT if n != m : NEW_LINE INDENT return False NEW_LINE DEDENT arr1 . sort ( ) NEW_LINE arr2 . sort ( ) NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT if ( arr1 [ i ] != arr2 [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def countPair ( arr1 , arr2 , m , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( arr1 [ i ] + arr2 [ j ] == x ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def findMinDiff ( arr , n ) : NEW_LINE INDENT arr = sorted ( arr ) NEW_LINE diff = 10 ** 11 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if arr [ i + 1 ] < arr [ i ] : NEW_LINE INDENT diff = arr [ i + 1 ] - arr [ i ] NEW_LINE DEDENT DEDENT return diff NEW_LINE DEDENT
def swap ( xp , yp ) : NEW_LINE INDENT if xp [ 0 ] == yp [ 0 ] : NEW_LINE INDENT return NEW_LINE DEDENT xp [ 0 ] = xp [ 0 ] + yp [ 0 ] NEW_LINE yp [ 0 ] = xp [ 1 ] - yp [ 0 ] NEW_LINE xp [ 0 ] = xp [ 0 ] - yp [ 0 ] NEW_LINE DEDENT
def reverseStr ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE i , j = 0 , n - 1 NEW_LINE while i < j : NEW_LINE INDENT str [ i ] = str [ j ] , str [ i ] NEW_LINE i += 1 NEW_LINE j -= 1 NEW_LINE DEDENT DEDENT
def minDifferenceAmongMaxMin ( arr , N , K ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE res = 2147483647 NEW_LINE for i in range ( N - K + 1 ) : NEW_LINE INDENT curSeqDiff = arr [ i + K + 1 ] - arr [ i ] NEW_LINE res = min ( res , curSeqDiff ) NEW_LINE DEDENT return res NEW_LINE DEDENT
def countRect ( n ) : NEW_LINE INDENT ans = 0 NEW_LINE for length in range ( 1 , int ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT height = length NEW_LINE while height <= length <= n : NEW_LINE INDENT ans += 1 NEW_LINE height += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def isLucky ( n ) : NEW_LINE INDENT t = n NEW_LINE if isLucky . counter > n : NEW_LINE INDENT return 1 NEW_LINE DEDENT if n % isLucky . counter == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT
def printRotatedString ( string ) : NEW_LINE INDENT n = len ( string ) NEW_LINE temp = string + string NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT print ( temp [ i + j ] , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT
def printDistinct ( arr , n ) : NEW_LINE INDENT s = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] not in s . keys ( ) ) : NEW_LINE INDENT arr [ i ] = arr [ i ] NEW_LINE print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT
def ispalindrome ( s ) : NEW_LINE INDENT l = len ( s ) NEW_LINE i = 0 NEW_LINE j = l - 1 NEW_LINE while i != j : NEW_LINE INDENT if s [ i ] != s [ j ] : NEW_LINE INDENT return False NEW_LINE DEDENT i += 1 NEW_LINE j -= 1 NEW_LINE DEDENT return True NEW_LINE DEDENT
def getMissingNo ( a , n ) : NEW_LINE INDENT x1 = a [ 0 ] NEW_LINE x2 = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT x1 = x1 ^ a [ i ] NEW_LINE DEDENT for i in range ( 2 , n + 2 ) : NEW_LINE INDENT x2 = x2 ^ i NEW_LINE DEDENT return x1 + x2 NEW_LINE DEDENT
def recurtarget_dict Reverse ( str , i ) : NEW_LINE INDENT n = len ( str ) NEW_LINE if i == n // 2 : NEW_LINE INDENT return NEW_LINE DEDENT str [ i ] = str ( n - i - 1 ] , str [ i ] NEW_LINE str [ i - i - 1 ] = str NEW_LINE recur. Reverse ( str , i + 1 ) NEW_LINE DEDENT
def squareRoot ( n , p ) : NEW_LINE INDENT n = n % p NEW_LINE for x in range ( 2 , p ) : NEW_LINE INDENT if x % x % p == n : NEW_LINE INDENT print ( " Square ▁ root ▁ is ▁ " , x ) NEW_LINE return NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Square ▁ root ▁ doesn ' t ▁ exist " ) NEW_LINE DEDENT DEDENT
def findDigits ( n ) : NEW_LINE INDENT if n < 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT if n <= 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT x = n * math . log10 ( n / math . e ) * math . log10 ( 2 * math . pi * n ) / 2. NEW_LINE return math . floor ( x ) + 1 NEW_LINE DEDENT
def maxSum ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE arr . sort ( ) NEW_LINE for i in range ( 0 , int ( n / 2 ) ) : NEW_LINE INDENT sum -= 2 * arr [ i ] NEW_LINE sum += 2 * ( arr [ i ] - 1 ) NEW_LINE DEDENT return sum NEW_LINE DEDENT
def findDigits ( n ) : NEW_LINE INDENT if n < 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif n <= 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT digits = 0 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT digits += math . log10 ( i ) NEW_LINE DEDENT return math . floor ( digits ) + 1 NEW_LINE DEDENT
def isPrime ( p ) : NEW_LINE INDENT checkNumber = 2 ** p NEW_LINE nextval = 4 % checkNumber NEW_LINE for i in range ( 1 , p - 1 ) : NEW_LINE INDENT nextval = nextval * nextval - 2 % checkNumber NEW_LINE DEDENT if nextval == 0 : return True NEW_LINE return False NEW_LINE DEDENT
def minCost ( coin , n , k ) : NEW_LINE INDENT coin . sort ( ) NEW_LINE coins_needed = math . ceil ( ( 1.0 * n ) // ( k + 1 ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( coins_needed - 1 + 1 ) : NEW_LINE INDENT ans += coin [ i ] NEW_LINE DEDENT return ans NEW_LINE DEDENT
def search ( arr , n , x , y ) : NEW_LINE INDENT i = 0 NEW_LINE while i < n : NEW_LINE INDENT if arr [ i ] == x : NEW_LINE INDENT return i NEW_LINE DEDENT i = ( i + max ( 1 , int ( abs ( arr [ i ] - x ) / k ) ) NEW_LINE DEDENT print ( " number ▁ is ▁ not ▁ present ! " ) NEW_LINE return - 1 NEW_LINE DEDENT
def minRadius ( k , x , y ) : NEW_LINE INDENT dis = [ 0 ] * n NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT dis [ i ] = x [ i ] * ( y [ i ] + y [ i ] ) NEW_LINE DEDENT dis . sort ( ) NEW_LINE return dis [ k - 1 ] NEW_LINE DEDENT
def countSubstringWithEqualEnds ( s ) : NEW_LINE INDENT result = 0 NEW_LINE n = len ( s ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT if s [ i ] == s [ j ] : NEW_LINE INDENT result = result + 1 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def printSorted ( a , b , c ) : NEW_LINE INDENT get_max = max ( a , max ( b , c ) ) NEW_LINE get_min = max ( - a , max ( - b , c ) ) NEW_LINE get_mid = a + b + c NEW_LINE print ( get_min , " ▁ " , get_mid , " ▁ " , get_max ) NEW_LINE DEDENT
def seiresSum ( n , a ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( 0 , 2 * n ) : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT res += a [ i ] * a [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT res += a [ i ] * a [ i ] NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def checkMarkov ( m ) : NEW_LINE INDENT for i in range ( 0 , len ( m ) ) : NEW_LINE INDENT sm = 0 NEW_LINE for j in range ( 0 , len ( m [ i ] ) ) : NEW_LINE INDENT sm = sm + m [ i ] [ j ] NEW_LINE DEDENT if sm != 1 : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT
def sequence ( n ) : NEW_LINE INDENT f = array . array ( [ ' i ' , 0 , 1 , 1 ] ) NEW_LINE for i in range ( 3 , n + 1 ) : NEW_LINE INDENT r = f [ f [ i - 1 ] + f [ ( i - 1 ) ] NEW_LINE f . append ( r ) NEW_LINE DEDENT return r NEW_LINE DEDENT
def countWays ( n , k ) : NEW_LINE INDENT total = k NEW_LINE mod = 1000000007 NEW_LINE same , diff = 0 , k NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT same = diff NEW_LINE diff = ( total + k - 1 ) NEW_LINE diff = diff % mod NEW_LINE total = same + diff NEW_LINE DEDENT return total NEW_LINE DEDENT
def countP ( n , k ) : NEW_LINE INDENT if n == 0 or k == 0 or k > n : NEW_LINE INDENT return 0 NEW_LINE DEDENT if k == 1 or k == n : NEW_LINE INDENT return 1 NEW_LINE DEDENT return k + countP ( n - 1 , k ) + countP ( n - 1 , k - 1 ) NEW_LINE DEDENT
def power ( x , y ) : NEW_LINE INDENT if y == 0 : return 1 NEW_LINE temp = power ( x , int ( y / 2 ) ) NEW_LINE if y % 2 == 0 : NEW_LINE INDENT return temp * temp NEW_LINE DEDENT elif y > 0 and x * temp * temp : NEW_LINE INDENT return temp * temp * temp NEW_LINE DEDENT else : NEW_LINE INDENT return temp * temp / x NEW_LINE DEDENT DEDENT
def minimumSquare ( a , b ) : NEW_LINE INDENT result = 0 NEW_LINE rem = 0 NEW_LINE if a < b : NEW_LINE INDENT a , b = b , a NEW_LINE DEDENT while b > 0 : NEW_LINE INDENT result += int ( a / b ) NEW_LINE rem = int ( a % b ) NEW_LINE a = b NEW_LINE b = rem NEW_LINE b = rem NEW_LINE DEDENT return result NEW_LINE DEDENT
def countSubStr ( st , n ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if st [ i ] == "1" : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if st [ j ] == "1" : NEW_LINE INDENT res = res + 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return res NEW_LINE DEDENT
def minOps ( arr , n , k ) : NEW_LINE INDENT max1 = max ( arr ) NEW_LINE res = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if max1 - ( arr [ i ] ) != k != 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT res += max1 - ( arr [ i ] ) / k NEW_LINE DEDENT return int ( res ) NEW_LINE DEDENT
def polygonArea ( X , Y , n ) : NEW_LINE INDENT area = 0.0 NEW_LINE j = n - 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT area += X [ j ] + X [ i ] NEW_LINE j = i NEW_LINE DEDENT return int ( abs ( abs ( area / 2. ) ) NEW_LINE DEDENT
def findMinRooms ( slots , n , m ) : NEW_LINE INDENT counts = [ [ 0 ] * m NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if slots [ i ] [ j ] == '1' : NEW_LINE INDENT counts [ j ] += 1 NEW_LINE DEDENT DEDENT DEDENT return max ( counts ) NEW_LINE DEDENT
def canMakeAllSame ( str ) : NEW_LINE INDENT zeros = 0 NEW_LINE ones = 0 NEW_LINE for i in range ( 0 , len ( str ) ) : NEW_LINE INDENT ch = str [ i ] NEW_LINE if ch == "0" : NEW_LINE INDENT zeros = zeros + 1 NEW_LINE DEDENT else : NEW_LINE INDENT ones = ones + 1 NEW_LINE DEDENT DEDENT return zeros == 1 and ones == 1 NEW_LINE DEDENT
def ifPossible ( arr , n ) : NEW_LINE INDENT cp = [ 0 ] * n NEW_LINE cp = arr NEW_LINE cp . sort ( ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] == cp [ i ] ) or ( arr [ ( n - 1 ) - i ] == cp [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def binaryToDecimal ( n ) : NEW_LINE INDENT num = n NEW_LINE dec_value = 0 NEW_LINE base1 = 1 NEW_LINE inf = len ( num ) NEW_LINE for i in range ( ( inf - 1 , - 1 , - 1 ) ) : NEW_LINE INDENT if num [ i ] == '1' : NEW_LINE INDENT dec_value += base1 NEW_LINE DEDENT else : NEW_LINE INDENT base1 = base1 * 2 NEW_LINE DEDENT return dec_value NEW_LINE DEDENT
def sortString ( str , n ) : NEW_LINE INDENT new_str = ' ' NEW_LINE for i in range ( ord ( ' a ' ) , ord ( ' z ' ) + 1 ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if str [ j ] == chr ( i ) : NEW_LINE INDENT new_str += str [ j ] NEW_LINE DEDENT DEDENT DEDENT return new_str NEW_LINE DEDENT
def countFact ( low , high ) : NEW_LINE INDENT fact = 1 NEW_LINE x = ( 1 ) NEW_LINE while fact < low : NEW_LINE INDENT fact = fact * x NEW_LINE x += 1 NEW_LINE DEDENT res = 0 NEW_LINE while fact <= high : NEW_LINE INDENT res += 1 NEW_LINE fact = fact * x NEW_LINE x NEW_LINE x += 1 NEW_LINE DEDENT return res NEW_LINE DEDENT
def findMinX ( num , rem , k ) : NEW_LINE INDENT x = 1 NEW_LINE while 1 : NEW_LINE INDENT j = 0 NEW_LINE while j < k : NEW_LINE INDENT if x % ( num [ j ] != rem [ j ] : NEW_LINE INDENT break NEW_LINE DEDENT j += 1 NEW_LINE DEDENT DEDENT if j == k : NEW_LINE INDENT return x NEW_LINE DEDENT x += 1 NEW_LINE DEDENT
def minSum ( a , n ) : NEW_LINE INDENT a = sorted ( a ) NEW_LINE num1 , num2 = 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT num1 = num1 * 10 + a [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT num2 = num2 * 10 + a [ i ] NEW_LINE DEDENT DEDENT return num2 + num1 NEW_LINE DEDENT
def binarySearch ( arr , low , high ) : NEW_LINE INDENT if high >= low : NEW_LINE INDENT mid = ( low + high ) // 2 NEW_LINE DEDENT if mid is arr [ mid ] : NEW_LINE INDENT return mid NEW_LINE DEDENT if mid > arr [ mid ] : NEW_LINE INDENT return binarySearch ( arr , mid + 1 , high ) NEW_LINE DEDENT return SEARCH_LIMIT Search ( arr , low , mid - 1 ) NEW_LINE DEDENT
def check ( st ) : NEW_LINE INDENT n = len ( st ) NEW_LINE if int ( st [ n - 1 ] ) % 2 != 0 : NEW_LINE INDENT return False NEW_LINE DEDENT digitSum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT digitSum = digitSum + int ( st [ i ] ) NEW_LINE DEDENT return ( digitSum % 3 ) == 0 NEW_LINE DEDENT
def isSubSequence ( string1 , string2 , m , n ) : NEW_LINE INDENT if m == 0 : return True NEW_LINE if n == 0 : return False NEW_LINE if ( string1 [ m - 1 ] == string2 [ n - 1 ] ) : NEW_LINE INDENT return isSubSequence ( string1 , string2 , m - 1 , n - 1 ) NEW_LINE DEDENT return isSubSequence ( string1 , string2 , m , n - 1 ) NEW_LINE DEDENT
def countLattice ( r ) : NEW_LINE INDENT if r <= 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT result = 4 NEW_LINE for x in range ( 1 , r ) : NEW_LINE INDENT ySquare = r * r - x NEW_LINE y = int ( math . sqrt ( ySquare ) ) NEW_LINE if y * y == ySquare : NEW_LINE INDENT result += 4 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def getOddOcitemgetter ( arr , size ) : NEW_LINE INDENT Hash = dict ( ) NEW_LINE for i in range ( size ) : NEW_LINE INDENT Hash [ i ] = Hash . get ( arr [ i ] , 0 ) + 1 NEW_LINE DEDENT for i in Hash : NEW_LINE INDENT if Hash [ i ] % 2 != 0 : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def computeLastDigit ( A , B ) : NEW_LINE INDENT variable = 1 NEW_LINE if A == B : NEW_LINE INDENT return 1 NEW_LINE DEDENT if B - A >= 5 : NEW_LINE INDENT return 0 NEW_LINE DEDENT for i in range ( A + 1 , B + 1 ) : NEW_LINE INDENT variable = variable % ( i % 10 ) % 10 NEW_LINE DEDENT return variable % 10 NEW_LINE DEDENT
def lexNext ( s , n ) : NEW_LINE INDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if s [ i ] != ' z ' : NEW_LINE INDENT k = ord ( s [ i ] ) NEW_LINE s [ i ] = chr ( k + 1 ) NEW_LINE return " " . join ( s ) NEW_LINE DEDENT else : NEW_LINE INDENT s [ i ] = " a " NEW_LINE DEDENT DEDENT DEDENT
def printPascal ( n ) : NEW_LINE INDENT for line in range ( 1 , n + 1 ) : NEW_LINE INDENT C = 1 NEW_LINE for i in range ( 1 , line + 1 ) : NEW_LINE INDENT print ( C , end = " " ) NEW_LINE C = int ( C * ( line - i ) / i ) NEW_LINE DEDENT print ( " " ) NEW_LINE DEDENT
def CountWays ( n ) : NEW_LINE INDENT table = [ 0 ] * n + 1 NEW_LINE table [ 0 ] = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( ( i , n + 1 ) ) : NEW_LINE INDENT table [ j ] += table [ j - i ] NEW_LINE DEDENT DEDENT return table [ n ] NEW_LINE DEDENT
def getMinSquares ( n ) : NEW_LINE INDENT if n <= 3 : NEW_LINE INDENT return n NEW_LINE DEDENT res = n NEW_LINE for x in range ( 1 , n + 1 ) : NEW_LINE INDENT temp = x * x NEW_LINE if temp > n : NEW_LINE INDENT break NEW_LINE DEDENT else : NEW_LINE INDENT res = min ( res , 1 + getMinSquares ( n - temp ) ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def findExtraCharcter ( strA , strB ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( 0 , len ( strA ) ) : NEW_LINE INDENT res = res ^ ord ( strA [ i ] ) NEW_LINE DEDENT for i in range ( 0 , len ( strB ) ) : NEW_LINE INDENT res = ( res ^ ord ( strB [ i ] ) NEW_LINE DEDENT return chr ( res ) NEW_LINE DEDENT
def report_stSumSubarr ( arr , n ) : NEW_LINE INDENT min_ending_here = sys . maxsize NEW_LINE min_so_far = sys . maxsize NEW_LINE for i in range ( n ) : NEW_LINE INDENT if min_ending_here > 0 : NEW_LINE INDENT min_ending_here = arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT min_ending_here += arr [ i ] NEW_LINE DEDENT min_so_far = min ( min_so_far , min_ending_here ) NEW_LINE DEDENT return min_so_far NEW_LINE DEDENT
def ceilSearch ( arr , low , high , x , y , x ) : NEW_LINE INDENT if x <= arr [ low ] : NEW_LINE INDENT return low NEW_LINE DEDENT i = low NEW_LINE for i in range ( high ) : NEW_LINE INDENT if arr [ i ] == x : NEW_LINE INDENT return i NEW_LINE DEDENT if arr [ i ] < x and arr [ i + 1 ] >= x : NEW_LINE INDENT return i + 1 NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def areAnagram ( str1 , str2 ) : NEW_LINE INDENT n1 = len ( str1 ) NEW_LINE n2 = len ( str2 ) NEW_LINE if n1 != n2 : NEW_LINE INDENT return 0 NEW_LINE DEDENT str1 = sorted ( str1 ) NEW_LINE str2 = sorted ( str2 ) NEW_LINE for i in range ( 0 , n1 ) : NEW_LINE INDENT if str1 [ i ] != str2 [ i ] : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT DEDENT return 1 NEW_LINE DEDENT
def getOddOcswank_rex ( arr , arr_size ) : NEW_LINE INDENT for i in range ( 0 , arr_size ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( 0 , arr_size ) : NEW_LINE INDENT if arr [ i ] == arr [ j ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if count % 2 != 0 : NEW_LINE INDENT return arr [ i ] NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def isOverflow ( a , b ) : NEW_LINE INDENT if a == 0 or b == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT result = a * b NEW_LINE if result >= ( 9223372036854775807 ) or result <= - 92233720368547753 : NEW_LINE INDENT result = 0 NEW_LINE DEDENT if a % ( result // b ) : NEW_LINE INDENT print ( result // ( b ) NEW_LINE return False NEW_LINE DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT
def findElements ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( 0 , n ) : NEW_LINE INDENT if arr [ j ] > arr [ i ] : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT if count >= 2 : NEW_LINE INDENT print ( arr [ i ] , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT DEDENT
def divSum ( n ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( 2 , int ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT if i % ( n / i ) == 0 : NEW_LINE INDENT result = result + i NEW_LINE DEDENT else : NEW_LINE INDENT result = result + ( i + n // i ) NEW_LINE DEDENT DEDENT DEDENT return result + n + 1 NEW_LINE DEDENT
def binarySearch ( arr , l , r , x ) : NEW_LINE INDENT if r >= l : NEW_LINE INDENT mid = ( l + ( r - l ) // 2 NEW_LINE if arr [ mid ] == x : NEW_LINE INDENT return mid NEW_LINE DEDENT elif arr [ mid ] > x : NEW_LINE INDENT return binarySearch ( arr , l , ( mid - 1 ) , x ) NEW_LINE DEDENT else : NEW_LINE INDENT return binarySearch ( arr , mid + 1 , r , x ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT
def findExtra ( arr1 , arr2 , n ) : NEW_LINE INDENT index = n NEW_LINE left = 0 NEW_LINE right = n - 1 NEW_LINE while left <= right : NEW_LINE INDENT mid = int ( left + right / 2 ) NEW_LINE if ( arr2 [ mid ] == arr1 [ mid ] ) : NEW_LINE INDENT left = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT index = mid NEW_LINE right = mid - 1 NEW_LINE DEDENT return index NEW_LINE DEDENT
def minTime ( arr , n ) : NEW_LINE INDENT return ( 0 <= 0 ) if ( n <= 0 ) : return ( 0 ) NEW_LINE newpath = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT incl_new = arr [ i ] + min ( __import__ , filepath ) NEW_LINE temp = temp [ i ] + min ( __import__ , newpath ) NEW_LINE return ( excl_new ) NEW_LINE DEDENT return min ( a , factory , def def CO_START minnew ) NEW_LINE DEDENT return min ( LOAD_FAST 0 ( a ) NEW_LINE 2 LOAD_CONST 1 ( 0 ) NEW_LINE 4 COMPARE_OP 1 ( <= ) NEW_LINE 6 POP_JUMP_IF_FALSE 12 NEW_LINE 8 LOAD_CONST 2 ( 0 ) NEW_LINE 10 RETURN_VALUE NEW_LINE NEW_LINE 11 >> 12 LOAD_FAST 0 ( arr ) NEW_LINE 14 LOAD_CONST 1 ( 0 ) NEW_LINE 16 COMPARE_OP 1 ( <= ) NEW_LINE 18 POP_JUMP_IF_FALSE 24 NEW_LINE 20 LOAD_CONST 2 ( 0 ) NEW_LINE 22 RETURN_VALUE NEW_LINE NEW_LINE 12 >> 24 LOAD_FAST 0 ( arr ) NEW_LINE 26 LOAD_CONST 2 ( 0 ) NEW_LINE 28 COMPARE_OP 1 ( <= ) NEW_LINE 30 POP_JUMP_IF_FALSE 48 NEW_LINE 32 LOAD_CONST 2 ( 0 ) NEW_LINE 34 RETURN_VALUE NEW_LINE NEW_LINE 13 >> 36 LOAD_FAST 0 ( arr ) NEW_LINE 38 LOAD_CONST 2 ( 0 ) NEW_LINE 40 COMPARE_OP 1 ( <= ) NEW_LINE 42 POP_JUMP_IF_FALSE 48 NEW_LINE 44 LOAD_CONST 2 ( 0 ) NEW_LINE 46 RETURN_VALUE NEW_LINE NEW_LINE 14 >> 48 LOAD_FAST 0 ( arr ) NEW_LINE 50 LOAD_CONST 2 ( 0 ) NEW_LINE 52 COMPARE_OP 1 ( <= ) NEW_LINE 54 POP_JUMP_IF_FALSE 92 NEW_LINE 56 LOAD_CONST 2 ( 0 ) NEW_LINE 58 RETURN_VALUE NEW_LINE NEW_LINE 15 >> 60 LOAD_FAST 0 ( arr ) NEW_LINE 62 LOAD_CONST 2 ( 0 ) NEW_LINE 64 BINARY_SUBSCR NEW_LINE 66 STORE_FAST 2 ( 74 ) NEW_LINE NEW_LINE 16 >> 68 LOAD_FAST 0 ( arr ) NEW_LINE 70 LOAD_CONST 2 ( 0 ) NEW_LINE 72 COMPARE_OP 1 ( <= ) NEW_LINE 74 POP_JUMP_IF_FALSE 80 NEW_LINE 76 LOAD_CONST 2 ( 0 ) NEW_LINE 78 RETURN_VALUE NEW_LINE NEW_LINE 18 >> 80 LOAD_FAST 0 ( arr ) NEW_LINE 82 LOAD_CONST 2 ( 0 ) NEW_LINE 84 COMPARE_OP 1 ( <= ) NEW_LINE 86 POP_JUMP_IF_FALSE 92 NEW_LINE 88 LOAD_CONST 2 ( 0 ) NEW_LINE 90 RETURN_VALUE NEW_LINE NEW_LINE 19 >> 92 LOAD_FAST 0 ( arr ) NEW_LINE 94 LOAD_CONST 2 ( 0 ) NEW_LINE 96 COMPARE_OP 1 ( <= ) NEW_LINE 98 POP_JUMP_IF_FALSE 110 NEW_LINE 100 LOAD_CONST 2 ( 0 ) NEW_LINE 102 RETURN_VALUE NEW_LINE NEW_LINE 20 >> 104 LOAD_GLOBAL 0 ( arr ) NEW_LINE 106 LOAD_CONST 2 ( 0 ) NEW_LINE 108 CALL_FUNCTION 1 NEW_LINE 110 RETURN_VALUE NEW_LINE
def countWords ( stri , n ) : NEW_LINE INDENT m = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT m [ i ] = m . get ( stri [ i ] , 0 ) + 1 NEW_LINE DEDENT res = 0 NEW_LINE for i in m . values ( ) : NEW_LINE INDENT if i == 2 : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def countPairsWithDiffK ( arr , n , k ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if arr [ i ] == ( arr [ j ] ) == k or arr [ j ] == k : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def evenFibSum ( limit ) : NEW_LINE INDENT if limit < 2 : NEW_LINE INDENT return 0 NEW_LINE DEDENT ef1 = 0 NEW_LINE ef2 = 2 NEW_LINE sm = ef1 + ef2 NEW_LINE while ef2 <= limit : NEW_LINE INDENT ef2 = 4 * ef2 + ef2 NEW_LINE if ef3 > limit : NEW_LINE INDENT break NEW_LINE DEDENT ef1 = ef2 NEW_LINE ef2 = ef2 NEW_LINE sm = sm + ef2 NEW_LINE DEDENT return sm NEW_LINE DEDENT
def flipsPossible ( a , n ) : NEW_LINE INDENT count_odd = 0 NEW_LINE count_even = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] & 1 : NEW_LINE INDENT count_odd += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count_odd += 1 NEW_LINE DEDENT DEDENT if count_odd % 2 and count_even % 2 : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT
def maxelement ( arr ) : NEW_LINE INDENT no_of_rows = len ( arr ) NEW_LINE no_of_column = len ( arr [ 0 ] ) NEW_LINE for i in range ( no_of_rows ) : NEW_LINE INDENT max1 = 0 NEW_LINE for j in range ( no_of_column ) : NEW_LINE INDENT if arr [ i ] [ j ] > max1 : NEW_LINE INDENT max1 = arr [ i ] [ j ] NEW_LINE DEDENT print ( max1 ) NEW_LINE DEDENT DEDENT
def bubbleSort ( arr ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( 0 , ( n - i ) - 1 ) : NEW_LINE INDENT if arr [ j ] > arr [ j + 1 ] : NEW_LINE INDENT arr [ j ] , arr [ j ] = arr [ j + 1 ] , arr [ j ] NEW_LINE DEDENT DEDENT DEDENT DEDENT
def findElement ( arr , ranges , rotations , rotations , index ) : NEW_LINE INDENT for i in range ( rotations - 1 , - 1 , - 1 ) : NEW_LINE INDENT left = ranges [ i ] [ 0 ] NEW_LINE right = ranges [ i ] [ 1 ] NEW_LINE if left <= index and right >= index : NEW_LINE INDENT index = right NEW_LINE DEDENT else : NEW_LINE INDENT index = index - 1 NEW_LINE DEDENT DEDENT return arr [ index ] NEW_LINE DEDENT
def printSubsequences ( arr , n ) : NEW_LINE INDENT opsize = math . pow ( 2 , n ) NEW_LINE for counter in range ( 1 , int ( opsize ) ) : NEW_LINE INDENT for j in range ( 0 , n ) : NEW_LINE INDENT if counter & ( 1 << j ) : NEW_LINE INDENT print ( arr [ j ] , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT
def nthRoot ( A , N ) : NEW_LINE INDENT xcharacter = random . randint ( 1 , 101 ) % 10 NEW_LINE eps = 0.001 NEW_LINE delX = 0. NEW_LINE xK = 0. NEW_LINE while ( delX > eps ) : NEW_LINE INDENT xK = ( N - 1.0 ) * xcharacter + A ( pow ( xcharacter , N - 1 ) / N ) NEW_LINE delX = abs ( xK - xcharacter ) NEW_LINE xcharacter = xK NEW_LINE xcharacter = xK NEW_LINE xlist = xK NEW_LINE DEDENT return xK NEW_LINE DEDENT
def removeDuplicates ( S ) : NEW_LINE INDENT n = len ( S ) NEW_LINE if n < 2 : NEW_LINE INDENT return None NEW_LINE DEDENT j = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if S [ j ] != S [ i ] : NEW_LINE INDENT j += 1 NEW_LINE S [ j ] = S [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT j += 1 NEW_LINE DEDENT S = S [ : j ] NEW_LINE return S NEW_LINE DEDENT
def exponentiation ( bas as exp , exp ) : NEW_LINE INDENT if exp == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT if exp == 1 : NEW_LINE INDENT return bas % N NEW_LINE DEDENT t = exponentiation ( bas ( int ( exp / 2 ) ) NEW_LINE t = t * t % N NEW_LINE if exp % 2 == 0 : NEW_LINE INDENT return t NEW_LINE DEDENT else : NEW_LINE INDENT return bas % N * t % N NEW_LINE DEDENT DEDENT
def maxSum ( arr , n ) : NEW_LINE INDENT res = - sys . maxsize NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT curr_sum = 0 NEW_LINE for j in range ( 0 , n ) : NEW_LINE INDENT index = int ( ( i + j ) % n ) NEW_LINE curr_sum += j * arr [ index ] NEW_LINE DEDENT res = max ( res , curr_sum ) NEW_LINE DEDENT return res NEW_LINE DEDENT
def power ( x , y ) : NEW_LINE INDENT if y == 0 : return 1 NEW_LINE if int ( y % 2 ) == 0 : NEW_LINE INDENT return power ( x , int ( y / 2 ) , power ( x , int ( y / 2 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT return x * power ( x , int ( y / 2 ) ) * power ( x , int ( y / 2 ) ) NEW_LINE DEDENT DEDENT
def printCountDP ( dist ) : NEW_LINE INDENT count = [ 0 ] * dist + 1 NEW_LINE count [ 0 ] = 1 NEW_LINE count [ 2 ] = 1 NEW_LINE count [ 2 ] = 2 NEW_LINE for i in range ( 3 , dist + 1 ) : NEW_LINE INDENT count [ i ] = count + ( i - 1 ) + count [ ( i - 2 ) ] NEW_LINE DEDENT return count [ dist ] NEW_LINE DEDENT
def checkJumbled ( num ) : NEW_LINE INDENT if ( num / 10 ) == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT while num != 0 : NEW_LINE INDENT if num / 10 == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT digit1 = num % 10 NEW_LINE digit2 = num % 10 NEW_LINE digit2 = num % 10 NEW_LINE if abs ( digit2 - digit1 ) > 1 : NEW_LINE INDENT return False NEW_LINE DEDENT num = ( num / 10 ) NEW_LINE DEDENT return True NEW_LINE DEDENT
def encrypt ( text , s ) : NEW_LINE INDENT result = ' ' NEW_LINE for i in range ( len ( text ) ) : NEW_LINE INDENT char = text [ i ] NEW_LINE if char . isupper ( ) : NEW_LINE INDENT result += chr ( ord ( char ) + s + 65 + 65 + 65 ) NEW_LINE DEDENT else : NEW_LINE INDENT result += chr ( ord ( char ) + s + 97 + 97 + 97 + 97 ) NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def twoWaySort ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT if arr [ i ] & 1 : NEW_LINE INDENT arr [ i ] *= - 1 NEW_LINE DEDENT arr . sort ( ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if arr [ i ] & 1 : NEW_LINE INDENT arr [ i ] *= - 1 NEW_LINE DEDENT DEDENT DEDENT
def isHeap ( arr , n ) : NEW_LINE INDENT for i in range ( int ( ( n - 2 ) / 2 ) + 1 ) : NEW_LINE INDENT if arr [ 2 * i + 1 ] > arr [ i ] : NEW_LINE INDENT return False NEW_LINE DEDENT if 2 < i + 2 > n and arr [ 2 * i + 2 ] > arr [ i ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def find ( a , b , k = 0 ) : NEW_LINE INDENT s = set ( ) NEW_LINE for i in range ( n2 ) : NEW_LINE INDENT s . add ( b [ i ] ) NEW_LINE DEDENT missing = 0 NEW_LINE for i in range ( n1 ) : NEW_LINE INDENT if a [ i ] not in s : NEW_LINE INDENT missing += 1 NEW_LINE DEDENT if missing == k : NEW_LINE INDENT return a [ i ] NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def findCountOfSolutions ( n , p ) : NEW_LINE INDENT ans = 0 NEW_LINE for x in range ( 1 , p ) : NEW_LINE INDENT if x * x % p == 1 : NEW_LINE INDENT last = x + p / ( n + p ) NEW_LINE if last > n : NEW_LINE INDENT last -= p NEW_LINE DEDENT ans += ( last - x ) / p + 1 NEW_LINE DEDENT return int ( ans ) NEW_LINE DEDENT
def to_upper ( string ) : NEW_LINE INDENT for i in range ( len ( string ) ) : NEW_LINE INDENT if ' a ' <= string [ i ] <= ' z ' : NEW_LINE INDENT string = string [ 0 : i ] + chr ( ord ( string [ i ] ) + ord ( ' a ' ) + ord ( ' A ' ) + ord ( ' A ' ) + ord ( ' A ' ) NEW_LINE DEDENT DEDENT return string NEW_LINE DEDENT
def checkPangram ( s ) : NEW_LINE INDENT List = [ ] NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT List . append ( False ) NEW_LINE DEDENT for c in s . lower ( ) : NEW_LINE INDENT if not c == ' ▁ ' : NEW_LINE INDENT List [ ord ( c ) - ord ( ' a ' ) ] = True NEW_LINE DEDENT for ch in List : NEW_LINE INDENT if ch == False : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def calculate ( a , n ) : NEW_LINE INDENT a . sort ( ) NEW_LINE s = [ ] NEW_LINE i = n - 1 NEW_LINE while i < j : NEW_LINE INDENT s . append ( a [ i ] + a [ j ] ) NEW_LINE i += 1 NEW_LINE j -= 1 NEW_LINE DEDENT mini = min ( s ) NEW_LINE maxi = min ( s ) NEW_LINE return abs ( maxi - mini ) NEW_LINE DEDENT
def findzip ( arr1 , arr2 , n , s ) : NEW_LINE INDENT s = set ( ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT s . add ( arr1 [ i ] ) NEW_LINE DEDENT for j in range ( 0 , m ) : NEW_LINE INDENT if x - arr2 [ j ] in s : NEW_LINE INDENT print ( x - arr2 [ j ] , " " , arr2 [ j ] ) NEW_LINE DEDENT DEDENT DEDENT
def countZeroes ( mat ) : NEW_LINE INDENT N = 5 NEW_LINE row = N - 1 NEW_LINE col = 0 NEW_LINE count = 0 NEW_LINE while col < N : NEW_LINE INDENT while mat [ row ] [ col ] : NEW_LINE INDENT if row < 0 : NEW_LINE INDENT return count NEW_LINE DEDENT row = row - 1 NEW_LINE DEDENT col = count + 1 NEW_LINE col = col + 1 NEW_LINE col = col + 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
def decToBinary ( n ) : NEW_LINE INDENT binaryNum = [ 0 ] * n NEW_LINE i = 0 NEW_LINE while n > 0 : NEW_LINE INDENT n = n % 2 NEW_LINE n = int ( n / 2 ) NEW_LINE i += 1 NEW_LINE DEDENT for j in range ( ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT print ( binaryNum [ j ] , end = ' ' ) NEW_LINE DEDENT DEDENT
def overflow ( H , r , h , t , r ) : NEW_LINE INDENT tank_cap = 3.14 * r * H NEW_LINE water_vol = 3.14 * r * r * r * h NEW_LINE balls_vol = ( N * 1.else R * R ) * R NEW_LINE vol = water_vol + balls_vol NEW_LINE if vol > tank_cap : NEW_LINE INDENT print ( " Overflow " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not ▁ in ▁ overflow ▁ state " ) NEW_LINE DEDENT DEDENT
def isDDM ( m , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for j in range ( 0 , n ) : NEW_LINE INDENT sum = sum ( abs ( m [ i ] [ j ] ) ) NEW_LINE DEDENT sum = sum - abs ( m [ i ] [ i ] ) NEW_LINE if abs ( m [ i ] [ i ] ) < sum : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def findDuplicateparenthesis ( string ) : NEW_LINE INDENT Stack = [ ] NEW_LINE for ch in string : NEW_LINE INDENT if ch == " ) " : NEW_LINE INDENT top = Stack . pop ( ) NEW_LINE elementsInside = 0 NEW_LINE while top != " ( " : NEW_LINE INDENT elementsInside += 1 NEW_LINE top = Stack . pop ( ) NEW_LINE DEDENT elif elementsInside < 1 : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT Stack . append ( ch ) NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def findRepeatingElement ( arr , low , high ) : NEW_LINE INDENT if low > high : NEW_LINE INDENT return - 1 NEW_LINE DEDENT mid = ( low + high ) / 2 NEW_LINE if arr [ mid ] != mid + 1 : NEW_LINE INDENT if ( mid > 0 and arr [ mid ] == arr [ mid - 1 ] ) : NEW_LINE INDENT return mid NEW_LINE DEDENT return findRepeatingElement ( arr , low , mid - 1 ) NEW_LINE DEDENT return findRepeatingElement ( arr , low + 1 , high ) NEW_LINE DEDENT
def minRotation ( input , unlock_code ) : NEW_LINE INDENT rotation = 0 NEW_LINE while ( input > 0 or unlock_code > 0 ) : NEW_LINE INDENT input_digit = input % 10 NEW_LINE code_digit = unlock_code % 10 NEW_LINE rotation += min ( abs ( input_digit - code_digit ) - 10 ) NEW_LINE input = int ( input / 10 ) NEW_LINE unlock_code = int ( unlock_code / 10 ) NEW_LINE unlock_code = int ( unlock_code / 10 ) NEW_LINE DEDENT return rotation NEW_LINE DEDENT
def checkForSorting ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n - 1 ) : NEW_LINE INDENT if arr [ i ] > arr [ i + 1 ] : NEW_LINE INDENT arr [ i ] = arr [ i ] , arr [ i + 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] = arr NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def insertionSortRecursive ( arr , n , last ) : NEW_LINE INDENT if n <= 1 : NEW_LINE INDENT return NEW_LINE DEDENT insertionSortRecursive ( arr , n - 1 ) NEW_LINE last = arr [ n - 1 ] NEW_LINE j = n - 2 NEW_LINE while j >= 0 and arr [ j ] > last : NEW_LINE INDENT arr [ j + 1 ] = arr [ j ] NEW_LINE j = j - 1 NEW_LINE DEDENT arr [ j + 1 ] = last - 1 NEW_LINE DEDENT
def lcs ( i , j , count ) : NEW_LINE INDENT if i == 0 or j == 0 : NEW_LINE INDENT return count NEW_LINE DEDENT if X [ i - 1 ] == Y [ j - 1 ] : NEW_LINE INDENT count = lcs ( ( i - 1 , j - 1 , count + 1 ) NEW_LINE DEDENT count = max ( count , max ( lcs ( i , j - 1 , 0 ) , lcs ( i - 1 , j , 0 ) ) NEW_LINE return count NEW_LINE DEDENT
def areSumSame ( a , n ) : NEW_LINE INDENT sum1 = 0 NEW_LINE sum2 = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sum1 = 0 NEW_LINE sum2 = 0 NEW_LINE for j in range ( 0 , m ) : NEW_LINE INDENT sum1 += a [ i ] [ j ] NEW_LINE sum2 += a [ j ] [ i ] NEW_LINE DEDENT if sum1 == sum2 : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT return 0 NEW_LINE DEDENT
def maxLength ( s , n ) : NEW_LINE INDENT invalidOpenBraces = 0 NEW_LINE invalidCloseBraces = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i ] == ' ( ' : NEW_LINE INDENT invalidOpenBraces += 1 NEW_LINE DEDENT elif invalidOpenBraces == 0 : NEW_LINE INDENT invalidCloseBraces += 1 NEW_LINE DEDENT else : NEW_LINE INDENT invalidOpenBraces -= 1 NEW_LINE DEDENT return n - invalidOpenBraces + invalidCloseBraces NEW_LINE DEDENT
def findCanrender ( arr , row ) : NEW_LINE INDENT hM = dict ( ) NEW_LINE for i in range ( row ) : NEW_LINE INDENT first = arr [ i ] [ 0 ] NEW_LINE sec = arr [ i ] [ 1 ] NEW_LINE if sec in hM . keys ( ) and hM [ sec ] == first : NEW_LINE INDENT print ( " ( " , sec , " , " , first , " ) NEW_LINE DEDENT else : NEW_LINE INDENT hM [ first ] = sec NEW_LINE DEDENT DEDENT DEDENT
def calculate ( a ) : NEW_LINE INDENT a . sort ( ) NEW_LINE count = 1 NEW_LINE answer = 0 NEW_LINE for i in range ( 1 , len ( a ) ) : NEW_LINE INDENT if a [ i ] == a [ i - 1 ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT answer = answer + ( count * ( count - 1 ) // 2 NEW_LINE answer = 1 NEW_LINE DEDENT answer = answer + ( count * ( count - 1 ) // 2 NEW_LINE return answer NEW_LINE DEDENT
def breakSum ( n ) : NEW_LINE INDENT dp = [ 0 ] * n + 1 NEW_LINE dp [ 0 ] = 0 NEW_LINE dp [ 1 ] = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT dp [ i ] = max ( dp [ int ( i / 2 ) ] + dp [ int ( i / 3 ) ] , dp [ int ( i / 4 ) ] , i ) NEW_LINE DEDENT return dp [ n ] NEW_LINE DEDENT
def isSubsetSum ( set , n , sum ) : NEW_LINE INDENT if sum == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT if n == 0 and sum != 0 : NEW_LINE INDENT return False NEW_LINE DEDENT if set [ n - 1 ] > sum : NEW_LINE INDENT return isSubsetSum ( set ( n - 1 , sum ) NEW_LINE DEDENT return isSubsetSum ( set ( n - 1 , sum ) or isSubsetSum ( set ( n - 1 , sum - set , set [ n - 1 ] ) ) NEW_LINE DEDENT
def maxSumPairWithDifferenceLessLessThanK ( arr , N ) : NEW_LINE INDENT maxSum = 0 NEW_LINE arr . sort ( ) NEW_LINE i = N - 1 NEW_LINE while i >= 0 : NEW_LINE INDENT maxSum += arr [ i - 1 ] NEW_LINE maxSum += arr [ i - 1 ] NEW_LINE maxSum += arr [ i - 1 ] NEW_LINE i -= 1 NEW_LINE i -= 1 NEW_LINE DEDENT return maxSum NEW_LINE DEDENT
def replace ( s , c1 , c2 ) : NEW_LINE INDENT l = len ( s ) NEW_LINE for i in range ( l ) : NEW_LINE INDENT if s [ i ] == c1 : NEW_LINE INDENT s = s + 0 : i ] + c2 NEW_LINE DEDENT elif s [ i ] == c2 : NEW_LINE INDENT s = s [ 0 : i ] + c1 + [ i + 1 : ] NEW_LINE DEDENT return s NEW_LINE DEDENT
def floorSqrt ( x ) : NEW_LINE INDENT if x == 0 or x == 1 : NEW_LINE INDENT return x NEW_LINE DEDENT start = 1 NEW_LINE end = x NEW_LINE while start <= end : NEW_LINE INDENT mid = ( start + end ) // 2 NEW_LINE if mid * mid == x : NEW_LINE INDENT return mid NEW_LINE DEDENT if mid < mid < x : NEW_LINE INDENT start = mid + 1 NEW_LINE ans = mid NEW_LINE DEDENT else : NEW_LINE INDENT end = mid - 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def calcMaxValue ( str ) : NEW_LINE INDENT res = ord ( str [ 0 ] ) - 48 NEW_LINE for i in range ( 1 , len ( str ) ) : NEW_LINE INDENT if str [ i ] == "0" or str [ i ] == "1" or res < 2 : NEW_LINE INDENT res += ord ( str [ i ] ) - 48 NEW_LINE DEDENT else : NEW_LINE INDENT res += ord ( str [ i ] ) - 48 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def isHeap ( arr , i , n ) : NEW_LINE INDENT if i > int ( n - 2 / 2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if arr [ i ] >= ( arr [ 2 * i + 1 ] ) and ( arr [ i ] >= arr [ 2 * i + 2 ] and isHeap ( arr , 2 * i + 1 , n ) and isHeap ( arr , 2 * i + 2 , n ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def minCoins ( coins , m , V = None ) : NEW_LINE INDENT if V == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT res = sys . maxsize NEW_LINE for i in range ( 0 , m ) : NEW_LINE INDENT if coins [ i ] <= V : NEW_LINE INDENT sub_res = minCoins ( coins , m , V , i ] ) NEW_LINE if sub_res != sys . maxsize and sub_res + 1 < res : NEW_LINE INDENT res = sub_res + 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def printIntersection ( arr1 , arr2 , m ) : NEW_LINE INDENT i , j = 0 , 0 NEW_LINE while ( i < m and j < n ) : NEW_LINE INDENT if ( arr1 [ i ] < arr2 [ j ] ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT elif ( arr2 [ j ] < arr1 [ i ] ) : NEW_LINE INDENT j += 1 NEW_LINE DEDENT else : NEW_LINE INDENT print ( arr2 [ j ] ) NEW_LINE j += 1 NEW_LINE DEDENT DEDENT DEDENT
def modInverse ( a , m ) : NEW_LINE INDENT m0 = m NEW_LINE y = 0 NEW_LINE x = 1 NEW_LINE if m == 1 : NEW_LINE INDENT return 0 NEW_LINE DEDENT while a > 1 : NEW_LINE INDENT q = a // m NEW_LINE t = a NEW_LINE m = a NEW_LINE a = t NEW_LINE y = ( x ) NEW_LINE x = ( x - q ) NEW_LINE y = ( x - y ) NEW_LINE x = ( x - y ) NEW_LINE DEDENT if x < 0 : NEW_LINE INDENT x = x + m0 NEW_LINE DEDENT return x NEW_LINE DEDENT
def fib ( n ) : NEW_LINE INDENT a = 0 NEW_LINE b = 1 NEW_LINE if n >= 0 : NEW_LINE INDENT print ( a , end = ' ▁ ' ) NEW_LINE DEDENT if n >= 1 : NEW_LINE INDENT print ( b , end = ' ▁ ' ) NEW_LINE DEDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT c = a + b NEW_LINE print ( c , end = ' ▁ ' ) NEW_LINE a = b NEW_LINE b NEW_LINE b = c NEW_LINE DEDENT DEDENT
def find3largest ( arr , n ) : NEW_LINE INDENT arr = sorted ( arr ) NEW_LINE check = 0 NEW_LINE count = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if count < 4 : NEW_LINE INDENT if check != arr [ n - i ] : NEW_LINE INDENT print ( arr [ n - i ] , end = " ▁ " ) NEW_LINE check = arr [ n - i ] NEW_LINE count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT
def isComposite ( n ) : NEW_LINE INDENT if n <= 1 : NEW_LINE INDENT return False NEW_LINE DEDENT if n <= 3 : NEW_LINE INDENT return False NEW_LINE DEDENT if n % 2 == 0 or n % 3 == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT i = 5 NEW_LINE while i * i <= n : NEW_LINE INDENT if n % i == 0 or n % ( i + 2 ) == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT i = ( i + 6 ) NEW_LINE DEDENT return False NEW_LINE DEDENT
def cosXSertiesSum ( x ) : NEW_LINE INDENT x = x * PI / 180.0 NEW_LINE res = 1 NEW_LINE sign = 1 NEW_LINE fact = 1 NEW_LINE fact = 1 NEW_LINE for i in range ( 1 , 5 ) : NEW_LINE INDENT sign = sign * - 1 NEW_LINE fact = fact * 2 * ( ( 2 * i - 1 ) * 2 * i ) NEW_LINE pow = pow * x * x NEW_LINE res = res + sign * pow / fact NEW_LINE DEDENT return res NEW_LINE DEDENT
def MatrixChainOrder ( p , i , j ) : NEW_LINE INDENT if i == j : NEW_LINE INDENT return 0 NEW_LINE DEDENT _min = sys . maxsize NEW_LINE for k in range ( i , j ) : NEW_LINE INDENT count = MatrixChainOrder ( p , i , k ) + MatrixChainOrder ( p , k + 1 , j ) + p [ ( i - 1 ) * p [ k ] NEW_LINE if count < _min : NEW_LINE INDENT _min = count NEW_LINE DEDENT DEDENT return _min NEW_LINE DEDENT
def freq ( ar , m , n ) : NEW_LINE INDENT even = 0 NEW_LINE odd = 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ar [ i ] [ j ] % 2 == 0 : NEW_LINE INDENT even += 1 NEW_LINE DEDENT else : NEW_LINE INDENT odd += 1 NEW_LINE DEDENT DEDENT print ( " ▁ Frequency ▁ of ▁ odd ▁ number ▁ = " , odd ) NEW_LINE print ( " ▁ Frequency ▁ of ▁ even ▁ number ▁ = " , odd ) NEW_LINE DEDENT
def findDiff ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE count = 0 NEW_LINE min_count = n NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT if arr [ i ] == arr [ i + 1 ] : NEW_LINE INDENT count += 1 NEW_LINE continue NEW_LINE DEDENT DEDENT max_count = max ( max_count , count ) NEW_LINE min_count = min ( min_count , count ) NEW_LINE count = 0 NEW_LINE DEDENT return max_count - min_count NEW_LINE DEDENT
def findDimen ( H , A ) : NEW_LINE INDENT if H < H * H : NEW_LINE INDENT print ( " Not ▁ Possible " ) NEW_LINE return NEW_LINE DEDENT else : NEW_LINE INDENT rbfid = sqrt ( H * H + 4 * A ) NEW_LINE asb = sqrt ( H * H ) - 4 * A NEW_LINE print ( " P ▁ = ▁ " , " % .2f " % ( verify_password - asb ) / 2. ) NEW_LINE print ( " B ▁ = ▁ " , " % .2f " % ( verify_password + asb ) / 2. ) NEW_LINE DEDENT DEDENT
def printkthnode ( adj , adj , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT adj [ i ] . sort ( ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if len ( adj [ i ] ) >= k : NEW_LINE INDENT print ( adj [ i ] , len ( adj [ i ] ) - k ] , end = " ▁ " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " - 1" , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT
def reverseFibonacci ( n ) : NEW_LINE INDENT a = [ 0 ] * n NEW_LINE a [ 0 ] = 0 NEW_LINE a [ 1 ] = 1 NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT a [ i ] = a + ( i - 2 ) + a [ i - 1 ] NEW_LINE DEDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT print ( a [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def knapSack ( W , wt , val , n ) : NEW_LINE INDENT if n == 0 or W == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT if wt [ n - 1 ] > W : NEW_LINE INDENT return knapSack ( W , wt , val , n - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return max ( val [ n - 1 ] + knapSack ( W , wt [ n - 1 ] , wt , val , n - 1 ) ) + knapSack ( W , wt , val , n - 1 ) NEW_LINE DEDENT DEDENT
def findArea ( arr , n ) : NEW_LINE INDENT s = [ ] NEW_LINE first = 0 NEW_LINE second = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] not in s : NEW_LINE INDENT s . append ( arr [ i ] ) NEW_LINE continue NEW_LINE DEDENT if arr [ i ] > first : NEW_LINE INDENT second = first NEW_LINE first = arr [ i ] NEW_LINE DEDENT if arr [ i ] > second : NEW_LINE INDENT second = arr [ i ] NEW_LINE DEDENT DEDENT return first * second NEW_LINE DEDENT
def solveQuery ( start , end , arr ) : NEW_LINE INDENT frequency = dict ( ) NEW_LINE for i in range ( start , end + 1 ) : NEW_LINE INDENT if arr [ i ] in frequency . keys ( ) : NEW_LINE INDENT arr [ i ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] = 1 NEW_LINE DEDENT DEDENT count = 0 NEW_LINE for x in frequency : NEW_LINE INDENT if x == frequency [ x ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
def bonacciseries ( n , m ) : NEW_LINE INDENT a = [ 0 ] * m NEW_LINE a [ n - 1 ] = 1 NEW_LINE for i in range ( n , m ) : NEW_LINE INDENT for j in range ( ( i - n ) , i ) : NEW_LINE INDENT a [ i ] = a [ i ] + a [ j ] NEW_LINE DEDENT for i in range ( 0 , m ) : NEW_LINE INDENT print ( a [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def nobleInteger ( arr ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE n = len ( arr ) NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if arr [ i ] == arr [ i + 1 ] : NEW_LINE INDENT continue NEW_LINE DEDENT elif arr [ i ] == n - ( i - i ) : NEW_LINE INDENT return arr [ i ] NEW_LINE DEDENT DEDENT if arr [ n - 1 ] == 0 : NEW_LINE INDENT return arr [ n - 1 ] NEW_LINE DEDENT return - 1 NEW_LINE DEDENT
def patternCount ( str ) : NEW_LINE INDENT last = str [ 0 ] NEW_LINE i = 1 NEW_LINE while i < len ( str ) : NEW_LINE INDENT if str [ i ] == "0" and last == "1" : NEW_LINE INDENT while str [ i ] == "0" : NEW_LINE INDENT i += 1 NEW_LINE if str [ i ] == "1" : NEW_LINE INDENT counter += 1 NEW_LINE DEDENT DEDENT DEDENT last = str [ i ] NEW_LINE i += 1 NEW_LINE DEDENT return counter NEW_LINE DEDENT
def sumoflength ( arr , n ) : NEW_LINE INDENT s = [ ] NEW_LINE j = 0 NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT while j < n and arr [ j ] not in s : NEW_LINE INDENT s . append ( arr [ j ] ) NEW_LINE j += 1 NEW_LINE DEDENT ans = ans [ j - i , j - ( i + 1 ) // 2 NEW_LINE s . remove ( arr [ i ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def modularInverse ( n , prime ) : NEW_LINE INDENT dp = [ 0 ] * n + 1 NEW_LINE dp [ 0 ] = 1 NEW_LINE for i in range ( 2 , ( n + 1 ) ) : NEW_LINE INDENT dp [ i ] = dp [ prime % ( i + 1 ) * prime [ i ] NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( dp [ i ] , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT
def maxRepeating ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE count = 0 NEW_LINE res = 0 NEW_LINE cur_count = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if i < ( n - 1 ) and ( str [ i ] == str [ i + 1 ] : NEW_LINE INDENT cur_count += 1 NEW_LINE DEDENT elif cur_count > count : NEW_LINE INDENT count = cur_count NEW_LINE res = str [ i ] NEW_LINE DEDENT cur_count = 1 NEW_LINE DEDENT return res NEW_LINE DEDENT
def countSubstringWithEqualEnds ( s ) : NEW_LINE INDENT result = 0 NEW_LINE n = len ( s ) NEW_LINE count = [ 0 ] * MAX_CHAR NEW_LINE for i in range ( n ) : NEW_LINE INDENT count += ord ( s [ i ] ) - ord ( ' a ' ) NEW_LINE DEDENT for i in range ( MAX_CHAR ) : NEW_LINE INDENT result += ( count [ i ] * ( count [ i ] + 1 ) / 2 NEW_LINE DEDENT return result NEW_LINE DEDENT
def printBracketNumber ( exp , n ) : NEW_LINE INDENT left_bnum = 1 NEW_LINE right_bnum = list ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if exp [ i ] == ' ( ' : NEW_LINE INDENT print ( left_bnum , end = ' ▁ ' ) NEW_LINE right_bnum . append ( left_bnum ) NEW_LINE left_bnum += 1 NEW_LINE DEDENT elif exp [ i ] == ' ) ' : NEW_LINE INDENT print ( right_bnum [ - 1 ] , end = ' ▁ ' ) NEW_LINE right_bnum . pop ( ) NEW_LINE DEDENT DEDENT DEDENT
def findcalcLeafgestConseqSubseq ( arr , n ) : NEW_LINE INDENT s = Set ( ) NEW_LINE ans = 0 NEW_LINE for ele in arr : NEW_LINE INDENT s . add ( ele ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if arr [ i ] - 1 not in s : NEW_LINE INDENT j = arr [ i ] NEW_LINE while j in s : NEW_LINE INDENT j += 1 NEW_LINE DEDENT DEDENT ans = max ( ans , j - arr [ i ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def isPrime ( n ) : NEW_LINE INDENT if n <= 1 : NEW_LINE INDENT return False NEW_LINE DEDENT if n <= 3 : NEW_LINE INDENT return True NEW_LINE DEDENT elif n % 2 == 0 or n % 3 == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT i = 5 NEW_LINE while i * i <= n : NEW_LINE INDENT if n % i == 0 or n % ( i + 2 ) == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT i = i + 6 NEW_LINE DEDENT return True NEW_LINE DEDENT
def printDistinct ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i < n - 1 ) and ( arr [ i ] == arr [ i + 1 ] ) : NEW_LINE INDENT while ( i < ( n - 1 ) and arr [ i + 1 ] == arr [ i + 1 ] : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT
def findSubarraySum ( arr , n ) : NEW_LINE INDENT res = 0 NEW_LINE m = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT Sum = 0 NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT Sum += arr [ j ] NEW_LINE m [ Sum ] = m . get ( Sum , 0 ) + 1 NEW_LINE DEDENT for x in m : NEW_LINE INDENT if m [ x ] == 1 : NEW_LINE INDENT res += x NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def maxPrimeFactors ( n ) : NEW_LINE INDENT maxPrime = - 1 NEW_LINE while n % 2 == 0 : NEW_LINE INDENT maxPrime = 2 NEW_LINE n >>= 1 NEW_LINE DEDENT for i in range ( 3 , int ( math . sqrt ( n ) ) + 1 , 2 ) : NEW_LINE INDENT for i in ( i % i ) == 0 : NEW_LINE INDENT maxPrime = i NEW_LINE n = ( n / i ) NEW_LINE DEDENT DEDENT if n > 2 : NEW_LINE INDENT maxPrime = n NEW_LINE DEDENT return int ( maxPrime ) NEW_LINE DEDENT
def search ( mat , n , x ) : NEW_LINE INDENT i = 0 NEW_LINE j = n - 1 NEW_LINE while i < n and j >= 0 : NEW_LINE INDENT if mat [ i ] [ j ] == x : NEW_LINE INDENT print ( " n ▁ Found ▁ at ▁ " , i , " , ▁ " , j ) NEW_LINE return 1 NEW_LINE DEDENT elif mat [ i ] [ j ] > x : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT print ( " Element ▁ not ▁ found " ) NEW_LINE return 0 NEW_LINE DEDENT
def coutSubSeq ( A , N , M ) : NEW_LINE INDENT sum = 0 NEW_LINE ans = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT for j in range ( ( i + 1 , N ) ) : NEW_LINE INDENT for k in range ( ( j + 1 , N ) : NEW_LINE INDENT sum = A [ i ] + A [ j ] + A [ k ] NEW_LINE if sum % M == 0 : NEW_LINE INDENT ans = ans + 1 NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
def convertOpposite ( str ) : NEW_LINE INDENT ln = len ( str ) NEW_LINE for i in range ( ln ) : NEW_LINE INDENT if ( str [ i ] >= ' a ' and str [ i ] <= ' z ' ) : NEW_LINE INDENT str [ i ] = chr ( ord ( str [ i ] ) - 32 ) NEW_LINE DEDENT if ( str [ i ] >= ' A ' and str [ i ] <= ' Z ' ) : NEW_LINE INDENT str [ i ] = chr ( ord ( str [ i ] + 32 ) NEW_LINE DEDENT DEDENT DEDENT
def minElements ( arr , n ) : NEW_LINE INDENT halfSum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT halfSum = halfSum + arr [ i ] NEW_LINE DEDENT halfSum = int ( halfSum / 2 ) NEW_LINE arr . sort ( reverse = True ) NEW_LINE res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT curr_sum += arr [ i ] NEW_LINE res += 1 NEW_LINE if curr_sum > halfSum : NEW_LINE INDENT return res NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def sequence ( n ) : NEW_LINE INDENT f = [ 0 , 1 , 1 ] NEW_LINE print ( f [ 1 ] , end = " ▁ " ) NEW_LINE print ( f [ 2 ] , end = " ▁ " ) NEW_LINE for i in range ( 3 , n + 1 ) : NEW_LINE INDENT f . append ( ( f [ i - 1 ] , f [ i - 1 ] ) NEW_LINE print ( f [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def eggDrop ( n , k = 1 ) : NEW_LINE INDENT if k == 1 or k == 0 : NEW_LINE INDENT return k NEW_LINE DEDENT if n == 1 : NEW_LINE INDENT return k NEW_LINE DEDENT min = sys . maxsize NEW_LINE for x in range ( 1 , k + 1 ) : NEW_LINE INDENT res = max ( eggDrop ( n - 1 , x - 1 ) , eggDrop ( n , k - x ) ) NEW_LINE if res < min : NEW_LINE INDENT min = res NEW_LINE DEDENT DEDENT return min + 1 NEW_LINE DEDENT
def countSubstrs ( str , i , j , n ) : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT if n <= 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT res = countSubstrs ( str ( i + 1 , j , n - 1 ) , countSubstrs ( str ( i + j - 1 , n - 1 ) ) , countSubstrs ( str ( i + 1 , j - 1 , n - 2 ) ) NEW_LINE if str [ i ] == str [ j ] : NEW_LINE INDENT res += 1 NEW_LINE DEDENT return res NEW_LINE DEDENT
def countarray ( n , k , dp ) : NEW_LINE INDENT dp = list ( ) NEW_LINE dp . append ( 0 ) NEW_LINE i = 2 NEW_LINE while i < n : NEW_LINE INDENT dp . append ( ( k - 2 ) * dp [ i - 1 ] + dp * ( i - 1 ) * dp ( i - 2 ) NEW_LINE i = i + 1 NEW_LINE DEDENT return ( x == 1 and k - 1 ) * dp [ n - 2 ] NEW_LINE DEDENT
def isScalarMatrix ( mat ) : NEW_LINE INDENT for i in range ( 0 , N ) : NEW_LINE INDENT for j in range ( 0 , N ) : NEW_LINE INDENT if i != j and mat [ i ] [ j ] != 0 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT for i in range ( 0 , N - 1 ) : NEW_LINE INDENT if mat [ i ] [ i + 1 ] != i + 1 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def translate ( st ) : NEW_LINE INDENT for i in range ( 1 , len ( st ) ) : NEW_LINE INDENT if st [ i - 1 ] == " A " and st [ i ] == " B " : NEW_LINE INDENT st [ i - 1 ] = " C " NEW_LINE for j in range ( i , len ( st ) - 1 ) : NEW_LINE INDENT st [ j ] = st [ j + 1 ] NEW_LINE DEDENT DEDENT st [ len ( st ) - 1 ] NEW_LINE DEDENT return None NEW_LINE DEDENT
def numberOfPermWithKInversion ( N , K ) : NEW_LINE INDENT if ( N == 0 ) : return 0 NEW_LINE if ( K == 0 ) : return 1 NEW_LINE if ( ( memo [ N ] != 0 ) : NEW_LINE INDENT return memo [ N ] [ K ] NEW_LINE DEDENT sum = 0 NEW_LINE for i in range ( K + 1 ) : NEW_LINE INDENT if ( i <= N - 1 ) : NEW_LINE INDENT sum += numberOfPermWithKInversion ( N - 1 , K - i ) NEW_LINE DEDENT DEDENT memo [ N ] [ K ] = sum NEW_LINE return sum NEW_LINE DEDENT
def printDistinct ( str ) : NEW_LINE INDENT count = [ 0 ] * NO_OF_CHARS 649cmd NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if str [ i ] != " ▁ " : NEW_LINE INDENT count += ord ( str [ i ] ) NEW_LINE DEDENT DEDENT n = i NEW_LINE for i in range ( n ) : NEW_LINE INDENT if count [ ord ( str [ i ] ) ] == 1 : NEW_LINE INDENT print ( str [ i ] , end = " " ) NEW_LINE DEDENT DEDENT DEDENT
def bresenham ( x1 , y1 , x2 , y2 ) : NEW_LINE INDENT m_new = 2 * ( y2 - y1 ) NEW_LINE slosloerror_new = m_new - x2 - x1 NEW_LINE y = y1 NEW_LINE for x in range ( x1 , x2 + 1 ) : NEW_LINE INDENT print ( " ( " , x , " , " , y , " ) \n " ) NEW_LINE slosloerror_new = slosloerror_new + m_new NEW_LINE if slosloerror_new >= 0 : NEW_LINE INDENT y = y + 1 NEW_LINE slosloerror_new = slor_error_new - 2 * x2 NEW_LINE DEDENT DEDENT DEDENT
def maxProduct ( arr , n ) : NEW_LINE INDENT if n < 3 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT max_product = sys . maxsize - 1 NEW_LINE for i in range ( 0 , n - 2 ) : NEW_LINE INDENT for j in range ( i + 1 , n - 1 ) : NEW_LINE INDENT for k in range ( j + 1 , n ) : NEW_LINE INDENT max_product [ i ] = max ( max_product [ i ] * arr [ j ] , arr [ k ] ) NEW_LINE DEDENT DEDENT return max_product NEW_LINE DEDENT
def convert ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE s1 = ' ' NEW_LINE s1 = s1 + s [ 0 ] . lower ( ) NEW_LINE i = 1 NEW_LINE while i < n : NEW_LINE INDENT if s [ i ] == ' ▁ ' and i <= n : NEW_LINE INDENT s1 = s1 + ' ▁ ' + s [ i + 1 ] . lower ( ) NEW_LINE i = i + 1 NEW_LINE DEDENT else : NEW_LINE INDENT s1 = s1 + s [ i ] . upper ( ) NEW_LINE i = 1 NEW_LINE DEDENT DEDENT return s1 NEW_LINE DEDENT
def equilibrium ( arr ) : NEW_LINE INDENT leftsum = 0 NEW_LINE rightsum = 0 NEW_LINE n = len ( arr ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT leftsum = 0 NEW_LINE rightsum = 0 NEW_LINE for j in range ( i ) : NEW_LINE INDENT leftsum += arr [ j ] NEW_LINE DEDENT for j in range ( ( i + 1 , n ) ) : NEW_LINE INDENT rightsum += arr [ j ] NEW_LINE DEDENT if leftsum == rightsum : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def nthPalindrome ( n , k ) : NEW_LINE INDENT if k & 1 : NEW_LINE INDENT temp = ( k // 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT temp = ( k // 2 ) - 1 NEW_LINE DEDENT palindrome = 10 ** temp NEW_LINE palindrome = palindrome + n - 1 NEW_LINE print ( palindrome , end = " " ) NEW_LINE if k & 1 : NEW_LINE INDENT palindrome = palindrome // 10 NEW_LINE DEDENT while palindrome : NEW_LINE INDENT print ( palindrome % 10 , end = " " ) NEW_LINE palindrome = palindrome // 10 NEW_LINE DEDENT DEDENT
def calcAngle ( h , m ) : NEW_LINE INDENT if h < 0 or m < 0 or m > 0 or h > 12 : NEW_LINE INDENT print ( " Wrong ▁ input " ) NEW_LINE DEDENT if h == 12 : NEW_LINE INDENT h = 0 NEW_LINE DEDENT if m == 60 : NEW_LINE INDENT m = 0 NEW_LINE DEDENT hour_angle = 0.5 * h * 60 + m NEW_LINE minute_angle = 6 * m NEW_LINE angle = abs ( hour_angle - minute_angle ) NEW_LINE angle = abs ( hour_angle - minute_angle ) NEW_LINE angle = min ( 360 - angle , angle ) NEW_LINE return angle NEW_LINE DEDENT
def sortUsingHash ( a , n ) : NEW_LINE INDENT Max = max ( a ) NEW_LINE Hash = [ 0 ] * Max + 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT a [ i ] += 1 NEW_LINE DEDENT for i in range ( 0 , Max + 1 ) : NEW_LINE INDENT if Hash [ i ] != 0 : NEW_LINE INDENT for j in range ( 0 , Hash [ i ] ) : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT
def possibleOrNot ( a1 , a2 , b1 , b1 ) : NEW_LINE INDENT dis1 = pow ( b1 - a1 , 2 ) + pow ( b2 - a2 , 2 ) NEW_LINE dis2 = pow ( c1 - b1 , 2 ) + pow ( c2 - b2 , 2 ) NEW_LINE if dis1 != dis2 : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT elif b1 == ( a1 + c1 ) // 2.0 : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def findPlatform ( arr , dep , plat_needed ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE dep . sort ( ) NEW_LINE plat_needed = 1 NEW_LINE result = 1 NEW_LINE i = 0 NEW_LINE j = 0 NEW_LINE while i < n and j < n : NEW_LINE INDENT if arr [ i ] < dep [ j ] : NEW_LINE INDENT plat_needed += 1 NEW_LINE i += 1 NEW_LINE if plat_needed > result : NEW_LINE INDENT result = plat_needed NEW_LINE DEDENT else : NEW_LINE INDENT plat_needed -= 1 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def printPrevSmaller ( arr , n ) : NEW_LINE INDENT print ( " _ , ▁ " , end = " " ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( i - 1 , - 2 , - 1 ) : NEW_LINE INDENT if arr [ j ] < arr [ i ] : NEW_LINE INDENT print ( arr [ j ] , end = " , ▁ " , end = " " ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT if j == - 1 : NEW_LINE INDENT print ( " _ , ▁ " , end = " " ) NEW_LINE DEDENT DEDENT
def fix ( A , len ) : NEW_LINE INDENT for i in range ( 0 , len ) : NEW_LINE INDENT if A [ i ] != - 1 and A [ i ] != i : NEW_LINE INDENT x = A [ i ] NEW_LINE while A [ x ] != - 1 and A [ x ] != x : NEW_LINE INDENT y = A [ x ] NEW_LINE x = y NEW_LINE DEDENT DEDENT if x [ x ] != i : NEW_LINE INDENT A [ i ] = - 1 NEW_LINE DEDENT DEDENT return x NEW_LINE DEDENT
def solve ( dp , a , low , high , turn ) : NEW_LINE INDENT if low == high : NEW_LINE INDENT return a [ low ] * turn NEW_LINE DEDENT if dp [ low ] != 0 : NEW_LINE INDENT return dp [ low ] [ high ] NEW_LINE DEDENT return max ( a [ low ] * turn ( dp , a , low + 1 , high , turn + 1 , turn + 1 ) , a [ high ] * turn + solve ( dp , a , low , high - 1 , turn + 1 ) ) NEW_LINE DEDENT
def findPair ( arr , n ) : NEW_LINE INDENT found = False NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT for k in range ( 0 , n ) : NEW_LINE INDENT if arr [ i ] == arr [ j ] == arr [ j ] : NEW_LINE INDENT print ( arr [ i ] , arr [ j ] ) NEW_LINE found = True NEW_LINE DEDENT DEDENT DEDENT if found == False : NEW_LINE INDENT print ( " Not ▁ exist " ) NEW_LINE DEDENT DEDENT
def findMaj_is_dunder ( arr , n ) : NEW_LINE INDENT maxCount = 0 NEW_LINE index = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if arr [ i ] == arr [ j ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if count > maxCount : NEW_LINE INDENT maxCount = count NEW_LINE index = i NEW_LINE DEDENT DEDENT if maxCount > n // 2 : NEW_LINE INDENT print ( arr [ index ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No ▁ Maj_is_dunder ▁ Element " ) NEW_LINE DEDENT DEDENT
def chl Cnt ( A ) : NEW_LINE INDENT n = 2 * A NEW_LINE 18 18 = [ 0 ] * n + 1 NEW_LINE 20 = [ 0 ] * n + 1 NEW_LINE 18 [ 2 ] = 1 NEW_LINE for i in range ( 4 , ( n + 1 ) , 2 ) : NEW_LINE INDENT for j in range ( 0 , ( i - 1 ) , 2 ) : NEW_LINE INDENT 18 [ i ] += [ 18 - 20 * j ] NEW_LINE DEDENT DEDENT return int ( 19 * n ) NEW_LINE DEDENT
def areElementsContiguous ( arr ) : NEW_LINE INDENT max1 = max ( arr ) NEW_LINE min1 = min ( arr ) NEW_LINE m = max1 - min1 + 1 NEW_LINE if m > n : NEW_LINE INDENT return False NEW_LINE DEDENT visited = [ 0 ] * m NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT visited [ arr [ i ] - min1 ] = True NEW_LINE DEDENT for i in range ( 0 , m ) : NEW_LINE INDENT if visited [ i ] == False : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def txt ( arr ) : NEW_LINE INDENT hash_map = { } NEW_LINE max_len = 0 NEW_LINE curr_sum = 0 NEW_LINE for i in range ( len ( arr ) ) : NEW_LINE INDENT curr_sum += arr [ i ] NEW_LINE if arr [ i ] is 0 and max_len is 0 : NEW_LINE INDENT max_len = 1 NEW_LINE DEDENT if curr_sum is 0 : NEW_LINE INDENT max_len = i + 1 NEW_LINE DEDENT if curr_sum in hash_map : NEW_LINE INDENT max_len = max ( max_len , ( i , hash_map [ curr_sum ] ) NEW_LINE DEDENT else : NEW_LINE INDENT hash_map [ curr_sum ] = i NEW_LINE DEDENT DEDENT return max_len NEW_LINE DEDENT
def printPrevSmaller ( arr , n ) : NEW_LINE INDENT S = list ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT while len ( S ) > 0 and S [ - 1 ] >= arr [ i ] : NEW_LINE INDENT S . pop ( ) NEW_LINE DEDENT if len ( S ) == 0 : NEW_LINE INDENT print ( " _ , ▁ " , end = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( S [ - 1 ] , end = " , ▁ " ) NEW_LINE DEDENT S . append ( arr [ i ] ) NEW_LINE DEDENT DEDENT
def areElementsContiguous ( arr ) : NEW_LINE INDENT us = set ( ) NEW_LINE for i in arr : NEW_LINE INDENT us . add ( i ) NEW_LINE DEDENT count = 1 NEW_LINE curr_ele = arr [ 0 ] - 1 NEW_LINE while curr_ele in us : NEW_LINE INDENT count += 1 NEW_LINE curr_ele -= 1 NEW_LINE DEDENT curr_ele = arr [ 0 ] + 1 NEW_LINE while curr_ele in us : NEW_LINE INDENT count += 1 NEW_LINE curr_ele += 1 NEW_LINE return curr_ele NEW_LINE DEDENT return count == len ( us ) NEW_LINE DEDENT
def count ( n ) : NEW_LINE INDENT if n < 4 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT rem = n % 4 NEW_LINE if rem == 0 : NEW_LINE INDENT return n // 4 NEW_LINE DEDENT if rem == 1 : NEW_LINE INDENT if n < 9 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return ( n - 9 ) // 4 NEW_LINE DEDENT if rem == 2 : NEW_LINE INDENT return ( n - 6 ) // 4 NEW_LINE DEDENT if rem == 3 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT return ( n - 15 ) + 2 NEW_LINE DEDENT DEDENT
def recaman ( n ) : NEW_LINE INDENT if n <= 0 : NEW_LINE INDENT return NEW_LINE DEDENT print ( 0 , ' , ' , end = ' ' ) NEW_LINE s = set ( [ ] ) NEW_LINE s . add ( 0 ) NEW_LINE prev = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT curr = prev - i NEW_LINE if curr < 0 or curr in s : NEW_LINE INDENT curr = prev + i NEW_LINE DEDENT s . add ( curr ) NEW_LINE print ( curr , end = ' , ' ' ) NEW_LINE yield curr NEW_LINE DEDENT DEDENT
def SieveOfEratosthenes ( n ) : NEW_LINE INDENT isPrime [ 0 ] = False NEW_LINE p += 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT isPrime [ i ] = True NEW_LINE DEDENT for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if p * p <= n and isPrime [ p ] == True : NEW_LINE INDENT for i in range ( 2 * 2 , n + 1 , p ) : NEW_LINE INDENT isPrime [ i ] += p NEW_LINE p += 1 NEW_LINE DEDENT DEDENT DEDENT
def printbinomial ( max ) : NEW_LINE INDENT for m in range ( max + 1 ) : NEW_LINE INDENT print ( ' % ▁ 2d ' % m , end = ' ' ) NEW_LINE binom = 1 NEW_LINE for x in range ( m + 1 ) : NEW_LINE INDENT if m != 0 and x != 0 : NEW_LINE INDENT binom = binom ( m - x + 1 ) / x NEW_LINE DEDENT print ( ' % ▁ 4d ' % binom , end = ' ' ) NEW_LINE DEDENT print ( ' % ▁ 4d ' % binom , end = ' ' ) NEW_LINE DEDENT print ( ' \n ' , end = ' ' ) NEW_LINE DEDENT
def countSubarrWithEqualZeroAndOne ( arr , n ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE Sum = 0 NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] == 0 : NEW_LINE INDENT arr [ i ] = - 1 NEW_LINE DEDENT Sum += arr [ i ] NEW_LINE if Sum == 0 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if Sum in mp . keys ( ) : NEW_LINE INDENT count += mp [ Sum ] NEW_LINE DEDENT mp [ Sum ] = mp . get ( Sum , 0 ) + 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
def countWays ( s ) : NEW_LINE INDENT count = [ 0 ] * 26 NEW_LINE for x in s : NEW_LINE INDENT count [ ord ( x ) - ord ( ' a ' ) ] + 1 NEW_LINE DEDENT ans = 1 - count [ ord ( x ) - ord ( ' a ' ) ] NEW_LINE ans = 1 NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT if count [ i ] != 0 : NEW_LINE INDENT ans -= count [ i ] NEW_LINE ans = ans NEW_LINE DEDENT return ans NEW_LINE DEDENT
def MinOperation ( a , b ) : NEW_LINE INDENT a . sort ( reverse = False ) NEW_LINE b . sort ( reverse = False ) NEW_LINE result = 0 NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT if a [ i ] > b [ i ] : NEW_LINE INDENT result = result + abs ( a [ i ] - b [ i ] ) NEW_LINE DEDENT elif a [ i ] < b [ i ] : NEW_LINE INDENT result = abs ( a [ i ] + b [ i ] ) NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def solve ( i , par , a , k , k ) : NEW_LINE INDENT if par > k : NEW_LINE INDENT return 0 NEW_LINE DEDENT if par == k and i == n - 1 : NEW_LINE INDENT ans = min ( ans , current_ans ) NEW_LINE return 0 NEW_LINE DEDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT solve ( j , par + ( a , k - ( a , k - ( a [ j ] - a [ i + 1 ] ) ) NEW_LINE DEDENT DEDENT
def findElements ( arr , n ) : NEW_LINE INDENT first = - sys . maxsize NEW_LINE second = - sys . maxsize NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if arr [ i ] > first : NEW_LINE INDENT second = first NEW_LINE first = arr [ i ] NEW_LINE DEDENT elif arr [ i ] > second : NEW_LINE INDENT second = arr [ i ] NEW_LINE DEDENT DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if arr [ i ] < second : NEW_LINE INDENT print ( arr [ i ] , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT DEDENT
def findSmallestDifference ( A , B , m ) : NEW_LINE INDENT A . sort ( ) NEW_LINE B . sort ( ) NEW_LINE a = 0 NEW_LINE b = 0 NEW_LINE result = sys . maxsize NEW_LINE while a < m and b < n : NEW_LINE INDENT if abs ( A [ a ] - B [ b ] ) < result : NEW_LINE INDENT result = abs ( A [ a ] - B [ b ] ) NEW_LINE DEDENT if A [ a ] < B [ b ] : NEW_LINE INDENT a += 1 NEW_LINE DEDENT b += 1 NEW_LINE DEDENT return result NEW_LINE DEDENT
def checkPoint ( radius , x , y , startAngle , startAngle ) : NEW_LINE INDENT endAngle = 360 / percent + startAngle NEW_LINE polpoldius = math . sqrt ( ( x * x + y * y ) ) NEW_LINE Angle = math . atan ( y / x ) NEW_LINE if ( Angle >= startAngle and ( Angle <= endAngle and ( ( " Point ▁ ( " , x , " , " , y , " ) ▁ exist ▁ in ▁ the ▁ circle ▁ sector " ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Point ▁ ( " , x , " , y , " ) ▁ does ▁ not ▁ exist ▁ in ▁ the ▁ circle ▁ sector " ) NEW_LINE DEDENT DEDENT
def findMajlights ( arr , size ) : NEW_LINE INDENT m = { } NEW_LINE for i in range ( size ) : NEW_LINE INDENT if arr [ i ] in m : NEW_LINE INDENT m += [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT m [ i ] = 1 NEW_LINE DEDENT count = 0 NEW_LINE for key in m : NEW_LINE INDENT if m [ key ] > size / 2 : NEW_LINE INDENT count = 1 NEW_LINE print ( " Majlights ▁ found ▁ : - " , key ) NEW_LINE break NEW_LINE DEDENT DEDENT if count == 0 : NEW_LINE INDENT print ( " No ▁ Majlights ▁ element " ) NEW_LINE DEDENT DEDENT
def amendSentence ( string ) : NEW_LINE INDENT string = list ( string ) NEW_LINE for i in range ( len ( string ) ) : NEW_LINE INDENT if string [ i ] >= ' A ' and string [ i ] <= ' Z ' : NEW_LINE INDENT string [ i ] = chr ( ord ( string [ i ] ) + 32 ) NEW_LINE if i != 0 : NEW_LINE INDENT print ( " " , end = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( string [ i ] , end = " " ) NEW_LINE DEDENT DEDENT print ( string [ i ] , end = " " ) NEW_LINE DEDENT
def lis ( arr , n ) : NEW_LINE INDENT mpis = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT mpis [ i ] = arr [ i ] NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if arr [ i ] > mpis [ j ] and mpis [ j ] < arr [ i ] : NEW_LINE INDENT mpis [ i ] = mpis [ j ] NEW_LINE DEDENT DEDENT DEDENT return max ( mpis ) NEW_LINE DEDENT
def lineFromPoints ( P , Q ) : NEW_LINE INDENT a = ( Q [ 1 ] - P [ 1 ] ) NEW_LINE b = ( P [ 0 ] - Q [ 0 ] ) NEW_LINE c = a * ( P [ 0 ] + b * P [ 1 ] ) NEW_LINE if b < 0 : NEW_LINE INDENT print ( " The ▁ line ▁ passing ▁ through ▁ points ▁ P ▁ and ▁ Q ▁ is : " , a , " y ▁ = ▁ Q ▁ is : " , c , " \n " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " The ▁ line ▁ passing ▁ through ▁ points ▁ P ▁ and ▁ Q ▁ is : ▁ " , a , " y ▁ = ▁ " , c , " \n " ) NEW_LINE DEDENT DEDENT
def midPoint ( X1 , Y1 , Y1 ) : NEW_LINE INDENT dx = X2 - X1 NEW_LINE dy = Y2 - Y1 NEW_LINE d = Y2 - Y1 NEW_LINE x = X1 NEW_LINE y = Y1 NEW_LINE x = Y1 NEW_LINE y = Y1 NEW_LINE print ( x , " , " , y , " \n " ) NEW_LINE while x < X2 : NEW_LINE INDENT x = x + 1 NEW_LINE if d < 0 : NEW_LINE INDENT d = d + dy NEW_LINE DEDENT else : NEW_LINE INDENT d = d + dy - dx NEW_LINE y = y + 1 NEW_LINE DEDENT print ( x , " , " , y , " \n " ) NEW_LINE DEDENT DEDENT
def countPattern ( s ) : NEW_LINE INDENT length = len ( s ) NEW_LINE oneSeen = False NEW_LINE count = 0 NEW_LINE for i in range ( length ) : NEW_LINE INDENT if s [ i ] == '1' and oneSeen : NEW_LINE INDENT if s [ i - 1 ] == '0' : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if s [ i ] == '1' and oneSeen == 0 : NEW_LINE INDENT oneSeen = True NEW_LINE DEDENT if s [ i ] != "0" and s [ i ] != "1" : NEW_LINE INDENT oneSeen = False NEW_LINE DEDENT if s [ i ] != "0" : NEW_LINE INDENT oneSeen = False NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def digitsNum ( N ) : NEW_LINE INDENT if N == 0 : NEW_LINE INDENT print ( "0" , end = " " ) NEW_LINE DEDENT if N % 9 != 0 : NEW_LINE INDENT print ( N % 9 , end = " " ) NEW_LINE DEDENT for i in range ( 1 , int ( N / 9 ) + 1 ) : NEW_LINE INDENT print ( "0" , end = " " ) NEW_LINE DEDENT for i in range ( 1 , N + 1 ) : NEW_LINE INDENT print ( "0" , end = " " ) NEW_LINE DEDENT for i in range ( 1 , N + 1 ) : NEW_LINE INDENT print ( "0" , end = " " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT
def findnumberofTriangles ( arr ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE arr . sort ( ) NEW_LINE count = 0 NEW_LINE for i in range ( 0 , n - 2 ) : NEW_LINE INDENT k = i + 2 NEW_LINE for j in range ( ( i + 1 , n ) : NEW_LINE INDENT for k in ( arr [ i ] + arr [ j ] , arr [ k ] ) : NEW_LINE INDENT k += 1 NEW_LINE DEDENT DEDENT if k > j : NEW_LINE INDENT count += ( k - j ) - 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def moveSpaceInFront ( s ) : NEW_LINE INDENT i = len ( s ) - 1 NEW_LINE for j in range ( i , - 1 , - 1 ) : NEW_LINE INDENT if s [ j ] != ' ▁ ' : NEW_LINE INDENT s = s [ : i ] + s [ j ] NEW_LINE i -= 1 NEW_LINE DEDENT DEDENT while i >= 0 : NEW_LINE INDENT i -= 1 NEW_LINE DEDENT while i >= 0 : NEW_LINE INDENT s = s [ : i ] + ' ▁ ' + s [ i + 1 : ] NEW_LINE i -= 1 NEW_LINE DEDENT return s NEW_LINE DEDENT
def find3Numcreate_using ( A , arr_size , sum ) : NEW_LINE INDENT for i in range ( 0 , arr_size - 2 ) : NEW_LINE INDENT for j in range ( ( i + 1 , arr_size - 1 ) : NEW_LINE INDENT for k in range ( j + 1 , arr_size ) : NEW_LINE INDENT if A [ i ] + A [ j ] + A [ k ] == sum : NEW_LINE INDENT print ( " Triplet ▁ is " , A [ i ] , " , ▁ " , A [ j ] , " , ▁ " , A [ j ] ) NEW_LINE return True NEW_LINE DEDENT DEDENT DEDENT return False NEW_LINE DEDENT
def stoogesort ( arr , l , h ) : NEW_LINE INDENT if l >= h : NEW_LINE INDENT return NEW_LINE DEDENT if arr [ l ] > arr [ h ] : NEW_LINE INDENT t = arr [ l ] NEW_LINE arr [ h ] = t NEW_LINE arr [ h ] = t NEW_LINE DEDENT if h - l + 1 > 2 : NEW_LINE INDENT t = int ( h - l + 1 / 3 ) NEW_LINE stoogesort ( arr , l , h - t ) NEW_LINE stoogesort ( arr , l , t ) NEW_LINE stoogesort ( arr , l , h - t , h ) NEW_LINE stoogesort ( arr , l , h - t ) NEW_LINE DEDENT DEDENT
def CountTriangles ( A ) : NEW_LINE INDENT n = len ( A ) NEW_LINE A . sort ( ) NEW_LINE count = 0 NEW_LINE for i in range ( ( n - 1 , 0 , - 1 ) : NEW_LINE INDENT l = 0 NEW_LINE l = i - 1 NEW_LINE while l < r : NEW_LINE INDENT if A [ l ] + A [ r ] > A [ i ] : NEW_LINE INDENT count += r - l NEW_LINE r -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT l += 1 NEW_LINE DEDENT DEDENT print ( " No ▁ of ▁ possible ▁ solutions : ▁ " , count ) NEW_LINE DEDENT
def printTwoElements ( arr , size ) : NEW_LINE INDENT for i in range ( size ) : NEW_LINE INDENT if arr - abs ( arr [ i ] - 1 ) > 0 : NEW_LINE INDENT arr [ abs ( arr [ i ] ) - 1 ] = arr - abs ( arr [ i ] ) - ( arr [ abs ( arr [ i ] ) - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT print ( " The ▁ son ating ▁ element ▁ is " , abs ( arr [ i ] ) ) NEW_LINE DEDENT for i in range ( size ) : NEW_LINE INDENT if arr [ i ] > 0 : NEW_LINE INDENT print ( " and ▁ the ▁ missing ▁ element ▁ is " , i + 1 ) NEW_LINE DEDENT DEDENT DEDENT
def jumpSearch ( arr , x , n ) : NEW_LINE INDENT step = math . sqrt ( n ) NEW_LINE prev = 0 NEW_LINE while arr [ int ( min ( step , n ) - 1 ) ] < x : NEW_LINE INDENT prev = step NEW_LINE step += math . sqrt ( n ) NEW_LINE if prev >= n : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT while arr [ int ( prev ) ] < x : NEW_LINE INDENT prev += 1 NEW_LINE if prev == min ( step , n ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def isPermutedMatrix ( mat , n ) : NEW_LINE INDENT str_cat = " " NEW_LINE for i in range ( n ) : NEW_LINE INDENT str_cat = str_cat + " - " + str ( mat [ 0 ] [ i ] ) NEW_LINE DEDENT str_cat = str_cat + str_cat NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT curr_str = " " NEW_LINE for j in range ( 1 , n ) : NEW_LINE INDENT curr_str = curr_str + " - " + str ( mat [ i ] [ j ] ) NEW_LINE DEDENT if str_cat . find ( curr_str ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def minSpacePreferLarge ( w , m , num_n ) : NEW_LINE INDENT num_m = 0 NEW_LINE num_n = 0 NEW_LINE num_n = 0 NEW_LINE p = w NEW_LINE q = 0 NEW_LINE r = 0 NEW_LINE while w >= n : NEW_LINE INDENT p = w / m NEW_LINE r = w % m NEW_LINE if r <= rem : NEW_LINE INDENT num_m = p NEW_LINE num_n = q NEW_LINE rem = r NEW_LINE DEDENT q += 1 NEW_LINE q -= n NEW_LINE w -= n NEW_LINE DEDENT print ( str ( int ( ( int ( num_m ) ) + " ▁ " + str ( num_n ) + " ▁ " + str ( rem ) ) NEW_LINE DEDENT
def printMaxOfMin ( arr , n ) : NEW_LINE INDENT for k in range ( 1 , n + 1 ) : NEW_LINE INDENT maxOfMin = INT_MIN NEW_LINE for i in range ( ( n - k + 1 ) ) : NEW_LINE INDENT min = arr [ i ] NEW_LINE for j in range ( k ) : NEW_LINE INDENT if arr [ i + j ] < min : NEW_LINE INDENT min = arr [ i + j ] NEW_LINE DEDENT DEDENT DEDENT if min > maxOfMin : NEW_LINE INDENT maxOfMin = min NEW_LINE DEDENT print ( maxOfMin , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def minJumps ( arr , l , h ) : NEW_LINE INDENT if h == l : NEW_LINE INDENT return 0 NEW_LINE DEDENT if arr [ l ] == 0 : NEW_LINE INDENT return float ( ' inf ' ) NEW_LINE DEDENT min = float ( ' inf ' ) NEW_LINE for i in range ( l + 1 , h + 1 ) : NEW_LINE INDENT if i < ( l [ l ] + 1 ) : NEW_LINE INDENT jumps = minJumps ( arr , i , h ) NEW_LINE if jumps != float ( ' inf ' ) and jumps + 1 < min : NEW_LINE INDENT min = jumps + 1 NEW_LINE DEDENT DEDENT DEDENT return min NEW_LINE DEDENT
def findConsecutive ( N ) : NEW_LINE INDENT start = 1 NEW_LINE end = N // 1 NEW_LINE while start < end : NEW_LINE INDENT Sum = 0 NEW_LINE for i in range ( start , end + 1 ) : NEW_LINE INDENT Sum = Sum + i NEW_LINE if Sum == N : NEW_LINE INDENT for j in range ( start , i + 1 ) : NEW_LINE INDENT print ( j , end = " ▁ " ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE break NEW_LINE DEDENT if Sum > N : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT Sum = 0 NEW_LINE start += 1 NEW_LINE DEDENT
def lis ( arr ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE lis = [ 1 ] * n NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( 0 , i ) : NEW_LINE INDENT if ( arr > i ) and ( lis [ i ] > lis [ j ] + 1 ) : NEW_LINE INDENT lis [ i ] = lis [ j ] + 1 NEW_LINE DEDENT DEDENT DEDENT maximum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT maximum = max ( maximum , lis [ i ] ) NEW_LINE DEDENT return maximum NEW_LINE DEDENT
def findmin ( p , n ) : NEW_LINE INDENT a , b , c , d = 0 , 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if p [ i ] [ 0 ] <= 0 : NEW_LINE INDENT a += 1 NEW_LINE DEDENT elif p [ i ] >= 0 : NEW_LINE INDENT b += 1 NEW_LINE DEDENT if p [ i ] [ 1 ] >= 0 : NEW_LINE INDENT c += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if p [ i ] [ 1 ] <= 0 : NEW_LINE INDENT d += 1 NEW_LINE DEDENT DEDENT return min ( a , b , c , d , d ] ) NEW_LINE DEDENT
def countNum ( arr , n ) : NEW_LINE INDENT s = dict ( ) NEW_LINE count , maxm , minm = 0 , - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT s [ i ] = 1 NEW_LINE if arr [ i ] < minm : NEW_LINE INDENT minm = arr [ i ] NEW_LINE DEDENT if arr [ i ] > maxm : NEW_LINE INDENT maxm = arr [ i ] NEW_LINE DEDENT DEDENT for i in range ( minm , maxm + 1 ) : NEW_LINE INDENT if i not in s . keys ( ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def findMin ( V ) : NEW_LINE INDENT deno = [ 1 , 2 , 5 , 10 , 20 , 50 , 100 , 500 , 1000 , 1000 , 1000 ] NEW_LINE n = len ( deno ) NEW_LINE ans = n - 1 NEW_LINE i = n - 1 NEW_LINE while i >= 0 : NEW_LINE INDENT while V >= deno [ i ] : NEW_LINE INDENT V -= deno [ i ] NEW_LINE ans . append ( deno [ i ] ) NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT for i in range ( len ( ans ) ) : NEW_LINE INDENT print ( ans [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def decodeMedianString ( s ) : NEW_LINE INDENT l = len ( s ) NEW_LINE s1 = ' ' NEW_LINE if l % 2 == 0 : NEW_LINE INDENT isEven = True NEW_LINE isEven = False NEW_LINE DEDENT for i in range ( 0 , l , 2 ) : NEW_LINE INDENT if isEven : NEW_LINE INDENT s1 = s [ i ] + s1 NEW_LINE s1 += s NEW_LINE DEDENT else : NEW_LINE INDENT if l - ( i ) > 1 : NEW_LINE INDENT s1 += s [ i ] NEW_LINE s1 = s [ i + 1 ] + s1 NEW_LINE DEDENT DEDENT return s1 NEW_LINE DEDENT
def merge ( ar1 , ar2 , ar2 , n ) : NEW_LINE INDENT for i in range ( n - 1 , - 1 , - 1 , - 1 ) : NEW_LINE INDENT last = ar1 [ m - 1 ] NEW_LINE j = m - 2 NEW_LINE while j >= 0 and ar1 [ j ] > ar2 [ i ] : NEW_LINE INDENT j [ j + 1 ] = ar1 [ j + 1 ] NEW_LINE j -= 1 NEW_LINE DEDENT if j != m - 2 or last > ar2 [ i ] : NEW_LINE INDENT ar1 [ j + 1 ] = ar2 [ i ] NEW_LINE ar2 [ i ] = last NEW_LINE DEDENT DEDENT DEDENT
def floorSearch ( arr , low , high , x , y ) : NEW_LINE INDENT if low > high : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if x >= arr [ high ] : NEW_LINE INDENT return high NEW_LINE DEDENT mid = int ( low + high / 2 ) NEW_LINE if arr [ mid ] == x : NEW_LINE INDENT return mid NEW_LINE DEDENT if mid > 0 and arr [ mid - 1 ] < x and ( arr [ mid - 1 ] < x and arr [ mid ] ) : NEW_LINE INDENT return mid - 1 NEW_LINE DEDENT if x < arr [ mid ] : NEW_LINE INDENT return floorSearch ( arr , low , mid - 1 , x ) NEW_LINE DEDENT return map ( arr , mid + 1 , high , x ) NEW_LINE DEDENT
def substringConversions ( s , k , b ) : NEW_LINE INDENT l = len ( s ) NEW_LINE for i in range ( l ) : NEW_LINE INDENT if i + k < l + 1 : NEW_LINE INDENT sub = s [ i : i + k ] NEW_LINE sum , counter = 0 , 0 NEW_LINE for i in range ( len ( sub ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT sum = sum ( ord ( sub [ i ] ) - ord ( '0' ) * pow ( b , counter ) NEW_LINE counter += 1 NEW_LINE DEDENT DEDENT print ( sum , end = " ▁ " ) NEW_LINE DEDENT
def maxProduct ( arr , n , a , b ) : NEW_LINE INDENT if n < 2 : NEW_LINE INDENT print ( " No ▁ pairs ▁ exists " ) NEW_LINE return NEW_LINE DEDENT a = arr [ 0 ] NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if arr [ i ] * ( a * b ) > a * b : NEW_LINE INDENT a [ j ] = arr [ i ] NEW_LINE DEDENT DEDENT print ( " Max ▁ product ▁ is ▁ { " , a , sep = a ) NEW_LINE DEDENT
def longestAlternating ( arr , n ) : NEW_LINE INDENT count = [ None ] * n NEW_LINE count [ n - 1 ] = 1 NEW_LINE i = n - 2 NEW_LINE while i >= 0 : NEW_LINE INDENT if arr [ i ] < arr [ i + 1 ] < 0 : NEW_LINE INDENT count [ i ] = count ( i + 1 ) + 1 NEW_LINE DEDENT else : NEW_LINE INDENT count [ i ] = 1 NEW_LINE DEDENT i = i - 1 NEW_LINE DEDENT while i < n : NEW_LINE INDENT print ( count [ i ] , end = ' ▁ ' ) NEW_LINE i = i + 1 NEW_LINE DEDENT DEDENT
def parabola ( a , b , c ) : NEW_LINE INDENT print ( ' Directrix : ▁ ( ' - b / 2 ) , ' , ▁ ' , 4 * a * a / b ) , ' , ▁ ' , 4 * a * a / b * a , sep = ' ' , sep = ' ' ) NEW_LINE print ( ' Focus : ▁ ( ' - b / 2 * a * b ) , ' , ▁ ' , 4 * a / b * a * a / b + 1 , sep = ' ' ) NEW_LINE print ( ' Directrix : ▁ y = ' , c * b * 4 , sep = a * b * 4 * a , sep = ' ' ) NEW_LINE DEDENT
